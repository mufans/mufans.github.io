[{"title":"dart笔记","date":"2021-09-04T16:07:48.000Z","path":"2021/09/05/dart笔记/","text":"final/const常量声明，const表示编译期常量,final运行时常量。 import导入关键字 1import 'dart:marth' as math 内置数据类型数字类型int 取值范围-2^53 ~2^53 ,double为64位双精度浮点类型。数字类型都是num的子类型。 列表用List或者[]表示 12List list = [1,2,3];var list2= [1,2,...list]; //...表示填充 集合类型用Set或者{}表示 12Set&lt;String&gt; set &#x3D; &#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125;;set.add(&quot;c&quot;); 映射类型用Map或者{}表示 123456Map map &#x3D; &#123; &#39;key&#39;:&#39;value1&#39;, &#39;key2&#39;:&#39;value2&#39;&#125;;map[&#39;key3&#39;] &#x3D; &#39;value3&#39;;String value &#x3D; map[&#39;key&#39;]; 枚举类型 枚举类型不能包含数据成员和方法。 123enum UserType&#123; vip,guest&#125;; 逻辑语句与操作符switch语句支持String 、enum、num等类型 三目运算符 1a?xx:xx 级联操作符 可以对类的成员进行链式调用 12345Event event &#x3D; Event();event ..id &#x3D;1 ..type&#x3D;&quot;&quot; ..name&#x3D;&quot;&quot;; 赋值操作符及空判断操作符 12345678A??&quot;999&quot; &#x2F;&#x2F; A为空返回999AA?? &#x3D; &quot;999&quot; &#x2F;&#x2F; AA为空则赋值&quot;999&quot;AA ~&#x2F; 999 &#x2F;&#x2F; AA对999整除Event event &#x3D; Event();event?.fit(); &#x2F;&#x2F; event不为空调用方法 var 和 dynamicDart是强类型语言。var是编译期语法糖，声明会自动推导出数据类型。dynamic表示动态类型，编译后是一个object类型，到运行时才对类型进行检查。var声明时没制定类型和赋值会被指定为dynamic,到赋值时才推导出类型。 函数方法方法可以省略返回值类型；参数可以不指定类型；可选参数用{}包裹,可选参数必须声明在最后 1234567func(String username,repoName,&#123;branch &#x3D; &quot;master&quot;&#125;)&#123; &#125;func(&quot;aaa&quot;,&quot;ccc&quot;); &#x2F;&#x2F; branch默认传masterfunc(&quot;aaac&quot;,&quot;bbb&quot;,branch:&quot;dev&quot;); &#x2F;&#x2F; 可选参数必须指定参数名称 闭包：方法可以作为参数传递 1234567callback(String text)&#123; return &quot;aaa&quot;;&#125;do(String calback(String text))&#123; calback(&quot;ttt&quot;);&#125; 类、接口继承构造函数普通构造函数 1234567891011121314151617181920class Person&#123; String name; int age; String id; Person(String name)&#123; this.name = name; &#125; // 语法糖，成员变量自动赋值 Person(this.name); // 构造函数外部进行赋值，但是外部无法访问this Person(String n,int a):name=n,age=a &#123; &#125; // 重定向 Person(String id):this(\"person\",10,id); Person(this.name,this.age,this.id);&#125; 命名构造函数 12345678910class Person&#123; String name; int age; String id; Person.json(Map m)&#123; this.name = m[\"name\"]; this.age = m[\"age\"]; this.id = m[\"id\"]; &#125;&#125; 工厂构造函数 factory关键字实现工厂构造方法，类似工厂方法模式，一般会将默认构造方法以_开头命名表示私有。工厂构造函数内部无法使用this关键字，类似静态方法。 123456789101112class Person&#123; static final Map&lt;String,Person&gt; _cache = &lt;String,Person&gt;&#123;&#125;; factory Person(name)&#123; if(_cache.containsKey(name)) return _cache[name]; Person p = Person._Internal(name); _cache[name] = p; return p; &#125; Person._Internal(this.name);&#125; 接口dart没有接口关键字，类或者abstarct抽象类可以作为接口，使用implements可以实现多个接口。 12345678910111213141516171819abstarct class Interface&#123; void doA();&#125;class InterfaceClass&#123; void doB();&#125;class Name implements Interface,InterfaceCalss&#123; @override void doA()&#123; &#125; @override void doB()&#123; &#125;&#125; 继承dart只支持单继承，通过extends关键字继承父类, super关键字调用父类 12345678class Base&#123; String name; Base(this.name);&#125;class Child extends Base &#123; Child(name):super(name);&#125; 获取对象类型 通过对象runtimeType返回Type类型对象即当前对象的类型。 is 关键字判断对象的类型, as关键字用来对象转型。 1234Person p = Person();p.runtimeTypep is Personp as Person call( )方法调用: 类内部声明了call方法，可以直接通过对象名称进行call方法的调用；通过typedef声明的方法也可以直接通过funcName.call进行调用。 12345678910111213Class CallTest&#123; call(int i) =&gt; \"$i\";&#125;CallTest callTest = CallTest();callTest.call(1);callTest(1);typedef void MyFunction(int i);MyFunction func = (int i) =&gt; i;func(1);func.call(1); Mixin(混入模式)当类之间不存在继承关系，但是想赋予类另一个通用的行为，可以使用mixin. 使用 with关键字可以添加多个Mixin类. 1234567891011class Musician extends Performer with Musical &#123; // ···&#125;class Maestro extends Person with Musical, Aggressive, Demented &#123; Maestro(String maestroName) &#123; name = maestroName; canConduct = true; &#125;&#125; 通过创建一个继承自 Object 且没有构造函数的类，来 实现 一个 Mixin 。 如果 Mixin 不希望作为常规类被使用，使用关键字 mixin 替换 class 。 123456789101112131415mixin Musical &#123; bool canPlayPiano = false; bool canCompose = false; bool canConduct = false; void entertainMe() &#123; if (canPlayPiano) &#123; print('Playing piano'); &#125; else if (canConduct) &#123; print('Waving hands'); &#125; else &#123; print('Humming to self'); &#125; &#125;&#125; 使用on 关键字可以限制被Mixin的类的父类，声明了父类后，混入类本身相当于继承了该类，可以调用父类的方法 123456789Class Performer&#123; perform();&#125;mixin Musical on Performer&#123; play()&#123; perform(); &#125;&#125; mixin 混入顺序是从右到左，如果多个mixin类同时继承了父类，并且复写了父类的方法，如果方法内部没有调用super方法，调用流程将不会向左继续传递下去。 12345678910111213141516171819202122232425262728293031323334353637383940414243abstract class Base &#123; a()&#123; print(\"base a\"); &#125; b()&#123; print(\"base b\"); &#125;&#125;mixin A on Base &#123; a()&#123; print(\"A a\"); super.a(); &#125; b()&#123; print(\"A b\"); super.b(); &#125;&#125;mixin A2 on Base &#123; a()&#123; print(\"A2 a\"); // super.a(); &#125; b()&#123; print(\"A2 b\"); super.b(); &#125;&#125;class Child extends Base with A,A2&#123; &#125;main()&#123; Child child = Child(); child.a(); // 打印结果: A2 a child.b(); // 打印结果: A2 b -&gt; A b -&gt; base b&#125;","tags":[{"name":"dart","slug":"dart","permalink":"https://mufans.github.io/tags/dart/"}]},{"title":"gradle 插件调试","date":"2021-08-17T17:52:00.000Z","path":"2021/08/18/gradle/","text":"插件调试步骤 AS分别打开插件的P项目和依赖插件的D项目 插件项目创建remote调试配置 打开D项目编辑依赖插件的gradle Task,填入上次记录的jvm配置，将suspend改为y(执行时task会等待调试项目Attach) 修改suspend 双击该任务执行Task，terminal会提示正在监听端口，任务被挂起。然后，返回P项目打上断点点击调试按钮，发现D项目Task继续执行了，这时表示调试就成功了。 其他方式通过命令行连接调试 修改gradle配置 1export GRADLE_OPTS&#x3D;&quot;-agentlib:jdwp&#x3D;transport&#x3D;dt_socket,server&#x3D;y,suspend&#x3D;y,address&#x3D;5008&quot; 命令行添加如下参数， 1.&#x2F;gradlew clean assembleDebug -Dorg.gradle.debug&#x3D;true --no-daemon 注 经过多次尝试都无法成功，D项目的任务会一直卡死在start daemon无法被调试唤醒。","tags":[{"name":"gradle","slug":"gradle","permalink":"https://mufans.github.io/tags/gradle/"}]}]