[{"title":"Hexo指令","date":"2022-02-16T17:11:06.000Z","path":"2022/02/17/Hexo指令/","text":"hexo提供了一些指令，方便我们快速搭建博客和发布文章 初始化项目目 1$ hexo init [folder] folder 为可选参数表示初始化目录，默认为当前目录 新建文章 1$ hexo new [layout] title layout 有三种布局: post (直接发布的文章), draft (文章草稿) , page** (新的文章), 分别放在不同路径。 默认为post类型。 layout path draft source/_drafts post source/_posts page source page 创建新页面可以使用如下命令: 1$ hexo new page newPage 执行完会在source下创建newPage目录和index.md,之后就可以访问 https://xx.xx/newPage 主页下的内容了。 draft draft 是文章的草稿，文章在发布前可以先创建草稿 文章预览 1$ hexo server --draft 编辑完成可以后通过 publish 命令发布成 post 文章 1$ hexo publish draft newpage 生成静态页面 1$ hexo generate hexo g 简写 hexo d -g 部署后生成静态页面 启动服务 启动服务本地预览 1$ hexo server hexo s 简写 部署 1$ hexo d hexo d -g 部署生成静态页面 和 hexo -d g 等价","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://mufans.github.io/tags/Hexo/"}]},{"title":"Flutter笔记","date":"2021-09-18T01:37:18.000Z","path":"2021/09/18/Flutter笔记/","text":"Flutter笔记简介Flutter是谷歌开源的跨平台UI框架，支持移动端，web端，桌面以及嵌入式设备。 Flutter是自带渲染引擎的，可以实现平台无关的页面展示。另外也提供了与平台通信的api，补足UI以外的能力。 Flutter开发语言是Dart，是一种编译型语言。它提供了和js相似的语法糖。 Flutter支持热重载，开发比原生要高效。 框架 Flutter 架构图 Flutter框架由Framework,Engine,Embedder三层组成： Framework - 由Dart语言实现 包含两种UI样式 基础控件框架 布局渲染层：负责布局渲染，布局大小位置计算以及UI的变化 动画、画布绘图、手势支持 底层基础接口 Engine - C/C++ Skia渲染引擎 Dart运行时 Text文字排版引擎 PlatformChannels 原生平台通信接口 Embedder 嵌入层用来实现原生平台的扩展功能。 实现原理Flutter在原生平台相当于一个单页面应用，它需要原生平台提供一个容器。Android和IOS分别提供了Activity和ViewController作为原生页面的容器。 Flutter 会在容器中添加一个FlutterView,用于提供Surface, 然后Enigine层会将Framework的控件通过Skia绘制到Surface上。 Flutter一切皆为widget,通常开发只需要专注Widget层的UI实现就行。 编译产物Flutter编译的产物是可执行的二进制文件，安全性和代码的执行效率相对JS较高。 另外需要注意的是：如果没有重新安装而是始终使用热重载进行开发调试，杀掉进程后app会回退到了上一次安装的状态。发现Debug和Release包的产物不同，怀疑是Flutter为了提高热重载的效率启用了不同的编译方式。 热更新Flutter本身没有提供热更新的能力。但是Android可以尝试通过运行时替换so的方式实现。也有第三方例如淘宝的北海(kraken)框架进行了其他尝试，在上层增加了Js到Flutter的映射，通过更新JsBundle来实现热更新，但同时也带来了一部分性能上的损耗。 环境配置123export PUB_HOSTED_URL=https://pub.flutter-io.cn //国内用户需要设置export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn //国内用户需要设置export PATH=PATH_TO_FLUTTER_GIT_DIRECTORY/flutter/bin:$PATH 依赖库flutter的三方库由pub统一管理，可以在 &lt;www.pub.dev&gt; 上查看。 开发的库或者插件首先要打包上传到pub上，然后就可以在工程的pubspec.yaml文件上配置依赖。 版本号的规则： 版本号前添加”^”表示匹配最近的一个大版本，比如”^0.1.2”将会匹配所有0.x.x的最新库。 pubspec.yaml 配置示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374version: 1.0.0+1environment: sdk: \"&gt;=2.12.0 &lt;3.0.0\"dependencies: flutter: sdk: flutter retrofit: 2.0.1 dio: ^4.0.0 shared_preferences: ^2.0.6 cached_network_image: ^3.1.0 provider: ^5.0.0 event_bus: ^2.0.0 # The following adds the Cupertino Icons font to your application. # Use with the CupertinoIcons class for iOS style icons. cupertino_icons: ^1.0.2dev_dependencies: flutter_test: sdk: flutter retrofit_generator: 2.0.1 build_runner: 2.0.1# For information on the generic Dart part of this file, see the# following page: https://dart.dev/tools/pub/pubspec# The following section is specific to Flutter.flutter: # The following line ensures that the Material Icons font is # included with your application, so that you can use the icons in # the material Icons class. uses-material-design: true # To add assets to your application, add an assets section, like this: # assets: # - images/a_dot_burr.jpeg # - images/a_dot_ham.jpeg assets: - images/ # An image asset can refer to one or more resolution-specific \"variants\", see # https://flutter.dev/assets-and-images/#resolution-aware. # For details regarding adding assets from package dependencies, see # https://flutter.dev/assets-and-images/#from-packages # To add custom fonts to your application, add a fonts section here, # in this \"flutter\" section. Each entry in this list should have a # \"family\" key with the font family name, and a \"fonts\" key with a # list giving the asset and other descriptors for the font. For # example: # fonts: # - family: Schyler # fonts: # - asset: fonts/Schyler-Regular.ttf # - asset: fonts/Schyler-Italic.ttf # style: italic # - family: Trajan Pro # fonts: # - asset: fonts/TrajanPro.ttf # - asset: fonts/TrajanPro_Bold.ttf # weight: 700 # # For details regarding fonts from package dependencies, # see https://flutter.dev/custom-fonts/#from-packages 项目脚手架当我们新建一个Flutter工程时，Flutter插件会帮助我们创建一个Demo，里面包含了程序的入口和脚手架。通常我们都是基于这个脚手架进行开发。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798// main 表示程序的入口void main() &#123; // runApp 负责创建App启动页并进行展示 runApp(MyApp());&#125;class MyApp extends StatelessWidget &#123; // This widget is the root of your application. @override Widget build(BuildContext context) &#123; var routes = buildRoute(); // 因为Flutter可以看作一个单页面应用，MyApp作为最底层的父容器，可以说MaterialApp包含了整个app的主题样式 return MaterialApp( title: 'Flutter Demo', // 配置主题样式 theme: ThemeData( primarySwatch: Colors.blue, ), routes: routes, // 配置路由 home: MyHomePage(routes.keys.toList(), title: 'Flutter Demo Home Page'), // 配置首页 ); &#125; Map&lt;String, WidgetBuilder&gt; buildRoute() &#123; return &#123;\"first_widget\": (context) =&gt; FirstWidget()&#125;; &#125;&#125;class MyHomePage extends StatefulWidget &#123; MyHomePage(this.routesName, &#123;Key? key, required this.title&#125;) : super(key: key); final String title; final List&lt;String&gt; routesName; @override _MyHomePageState createState() =&gt; _MyHomePageState();&#125;class _MyHomePageState extends State&lt;MyHomePage&gt; &#123; int _counter = 0; void _incrementCounter() &#123; setState(() &#123; _counter++; &#125;); &#125; @override Widget build(BuildContext context) &#123; // Scaffold是脚手架容器，它包含了导航栏、抽屉、底部Tab布局，悬浮按钮等常用的功能 // 并且MaterialApp必须配合Scaffold使用，所以每个页面的根布局都要基于这个容器来实现。 return Scaffold( appBar: AppBar( title: Text(widget.title), ), body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ Text( 'You have pushed the button this many times:', ), Text( '$_counter', style: Theme.of(context).textTheme.headline4, ), Expanded( child: ListView.separated( itemCount: widget.routesName.length, separatorBuilder: (BuildContext context, int index) =&gt; Divider( color: Colors.grey, height: 1, ), itemBuilder: (BuildContext context, int index) &#123; return GestureDetector( onTap: () &#123; Navigator.pushNamed(context, widget.routesName[index]); &#125;, child: Container( color: Colors.white, padding: EdgeInsets.only( left: 15, right: 15, top: 5, bottom: 5), child: Text(widget.routesName[index]))); &#125;)) ], ), ), floatingActionButton: FloatingActionButton( onPressed: _incrementCounter, tooltip: 'Increment', child: Icon(Icons.add), ), // This trailing comma makes auto-formatting nicer for build methods. ); &#125;&#125; WidgetFlutter 一切皆为Widget, 可以说Widget是构成页面点基础。 无状态和有状态控件Flutter 包含两种控件，分别为StatelessWidget 和 StatefulWidget 。开发时需要继承这两个类实现自定义UI，然后进行多层嵌套组成一个完整的页面。同时这也是Flutter的一个诟病，一个复杂的页面通常会包含多层嵌套，必定会增加调试和维护的难度。所以如何封装Widget并且控制好Widget的粒度是Flutter开发最需要考量的问题。 StatelessWidget 表示无状态的控件 ，意思就是这个控件不包含变化的元素，每次都是重新构建。 实现无状态布局，需要通过继承StatelessWidget，在build方法中返回需要渲染的布局。 12345678910class TestStatelessWidget extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Expanded( child: Container( constraints: BoxConstraints.expand(), color: Colors.blue, child: Center(child: Text(\"I am Stateless\")))); &#125;&#125; StatefulWidget 表示有状态的控件，它是包含State状态的。当数据发生变化时,页面要同步更新。 StatefulWidget 只用来创建State实例，关键在于State的实现。State可以看作是Widget的代理，负责创建布局和业务逻辑的实现。 12345678910111213141516171819202122232425262728class TestStatefulWidget extends StatefulWidget &#123; @override State&lt;StatefulWidget&gt; createState() &#123; return TestStatefulWidgetState(); &#125;&#125;class TestStatefulWidgetState extends State&lt;TestStatefulWidget&gt; &#123; final List&lt;Color&gt; _colors = [Colors.red, Colors.blue]; int _colorPos = 0; @override Widget build(BuildContext context) &#123; return Expanded( child: GestureDetector( onTap: () &#123; setState(() &#123; _colorPos = (_colorPos + 1) % 2; &#125;); &#125;, child: Container( color: _colors[_colorPos], child: Center( child: Text(\"click to change color\"), ), ))); &#125;&#125; State 的生命周期StatefulWidget 生命周期如下所示： 包含下面几种生命周期方法： initState初始化状态，只会调用一次。 didChangeDependenciesinitState之后会调用，当InheritedWidget发生变化时会触发。例如Provide（利用InheritedWidget实现)，监听的数据发生变化时需要更新状态。 build构建控件 setState改变数据通知Widget刷新 didUpdateWidget在setState之后调用，表示控件发生更新 disposeWidget销毁时会调用，只会调用一次，可以用来回收资源。 常用控件Flutter控件分为几种类型：布局容器、滚动控件、单一控件以及脚手架控件。 容器 特性 Container 只有一个子Widget ，默认充满全屏，是一个复合容器，包含padding、margin、color、width、height、decoration等配置； Padding 只有一个Child, 嵌套child 用来设置它的padding Center 只有一个child, 嵌套设置居中效果 Stack 堆叠布局，多个child , 类似framelayout Column 垂直布局，多个child，类似Linearlayout ；包含 maxAxisXX 主轴 和crossAxisXX 副轴属性，用来设置对齐方向和 容器的大小 Row 水平布局，多个child, 类似Linearlayout；包含 maxAxisXX 主轴 和crossAxisXX 副轴属性，用来设置对齐方向和 容器的大小 Expanded 只有一个child 用于在Column和Row中,通过flex设置child的比重，类似Linearlayout的weight Wrap 自动换行 Table 表格布局 Flow 瀑布流布局 CustomMultiChildLayout 自定义布局 SizedBox 包含一个child,用来设置尺寸 ConstraintBox 约束布局 Flutter Widget 都是十分细粒度的，一般布局的对齐方式，边距，尺寸，边框样式等属性都是通过多个控件嵌套组合来实现。Container 作为一个复合的控件，包含了几乎所有的属性，是最常用的容器控件。 滚动布局 特性 ListView 列表，包含多个Child GridView 表格列表，包含多个Child SingleChildScrollView 滚动布局，包含单个Child 单一控件 特性 Text 文本 Image 图片 RichText 富文本 TextField 输入框 TextButton 按钮 脚手架控件 特性 MaterialApp app 顶层主页入口，用来配置主题，路由等 Scaffold 作为独立页面的脚手架容器，提供appbar, snackbar,drawer 等常用配置 AppBar 作为Scaffold的appbar属性来使用，提供导航栏，tabbar等功能。 路由动画图片加载数据持久化网络请求状态管理","tags":[]},{"title":"Koin","date":"2021-09-15T16:25:42.000Z","path":"2021/09/16/Koin/","text":"Koin介绍Koin 是基于kotlin 实现的轻量级依赖注入框架，支持DSL语法调用。 Koin 对比 Dagger/HiltKoin: 利用Kotlin 语言特性(大量使用了扩展方法、属性代理等)实现依赖注入,不会影响编译速度。 由Component、Module、Scope关键元素组成。 支持DSL语法调用,代码结构更加清晰。通过属性代理进行对象注入，在kotlin代码里使用起来相对比较方便。 没有使用到反射，基本无性能影响。 支持kotlin和java 只有运行时才会报错，会导致程序崩溃 Dagger/Hilt: 借助编译时注解KPT 生成模板辅助类实现依赖注入，Hilt 结合 Javasisit/ASM修改字节码省去inject调用。由于使用插件拦截构建流程，会影响编译速度。 由Component、Module、Scope关键元素组成。 使用时强依赖注解，包含各种注解, 部分注解的作用重复。 使用生成的辅助类实现注入，基本无性能影响。 支持kotlin和java 编译时期会报错，可靠性相对较高 Gradle依赖Kotlin 工程 12345678910// Add Maven Central to your repositories if neededrepositories &#123; mavenCentral() &#125;dependencies &#123; // Koin for Kotlin apps compile \"io.insert-koin:koin-core:$koin_version\" // Testing testCompile \"io.insert-koin:koin-test:$koin_version\"&#125; Android 工程 koin-android 依赖 koin-core，发现koin-android-viewmodel无需依赖,最新版本viewmodel部分实现已合入koin-android，所以只需依赖koin-android即可 12345678910// Add Maven Central to your repositories if neededrepositories &#123; mavenCentral() &#125;dependencies &#123; // Koin for Android - Scope feature // include koin-android-scope &amp; koin-android implementation \"io.insert-koin:koin-android:$koin_version\" implementation \"io.insert-koin:koin-android-viewmodel:$koin_version\"&#125; 官方示例以下是kotlin依赖注入的使用方式，Android为了支持四大组件和jetpack在koin-core库上进行了扩展，使用方式大同小异 1234567891011121314151617181920212223242526272829303132333435// 数据模型data class HelloMessage(val message: String = \" hello Koin!\")// 抽象接口interface HelloService &#123; fun hello(): String&#125;// 接口实现类 依赖数据模型class HelloServiceImpl(private val helloMessage: HelloMessage) : HelloService &#123; override fun hello(): String &#123; return \"Hey, $&#123;helloMessage.message&#125;\" &#125;&#125;// 被注入的组件，继承KoinComponentclass HelloApplication : KoinComponent &#123; // 通过属性代理注入HelloService private val helloService by inject&lt;HelloService&gt;() fun hello() = println(helloService.hello())&#125;// 定义Module对象，提供了DSL语法声明依赖的对象val helloModule = module &#123; single &#123; HelloMessage() &#125; single &#123; HelloServiceImpl(get()) as HelloService &#125;&#125;// 启动Koin,添加之前声明的ModulesstartKoin &#123; printLogger() modules(helloModule)&#125;// 然后就能直接使用了HelloApplication().hello() Koin-CoreKoin-Core是Koin的基础库, 提供了Koin完整的api KoinApplicationKoinApplication 实例是Koin容器，它包含了Koin实例，用来配置logger，properties和modules。 DSL语法创建KoinApplication两种方式： koinAppication{} - 创建一个独立的实例，需要自己管理。 startKoin{} - 创建一个实例，并绑定到GlobalContext上，通常是使用这种方式。 示例： 12345startKoin &#123; printLogger() // 日志 properties(mapOf(\"key\" to \"value\")) // 属性 modules(helloModule) // 模块&#125; moduleModule 是提供依赖对象的模块, 内部包含所有依赖对象的工厂。 koin也提供了一种DSL创建方式： 1234567891011121314class ComponentA()class ComponentB(val componentA:ComponentA)val moduleA = module&#123; single&#123;ComponentA()&#125;&#125;val moduleB = module&#123; single(ComponentB(get()))&#125;startKoin&#123; modules(moduleA,moduleB) // 注册多个module&#125; Moudle类 重载了plus操作符 123456789&#x2F;** * Help write list of Modules *&#x2F; operator fun plus(module: Module) &#x3D; listOf(this, module) &#x2F;** * Help write list of Modules *&#x2F; operator fun plus(modules: List&lt;Module&gt;) &#x3D; listOf(this) + modules 1val totalModule = moduleA+moduleB // 拼接多个module 覆盖module 和definition1234567891011121314151617val myModuleA = module &#123; single&lt;Service&gt; &#123; ServiceImp() &#125;&#125;val myModuleB = module &#123; single&lt;Service&gt; &#123; TestServiceImp() &#125;&#125;startKoin &#123; // 默认情况下，后注册的module会覆盖之前的 modules(myModuleA,myModuleB)&#125;startKoin &#123; // 禁止覆盖 allowOverride(false)&#125; Scope definition single - 定义单例 factory - 普通工厂，每次注入都会重新创建对象 scoped - 创建对象与作用域生命周期关联 12345678910111213141516class MyService()val myModule = module &#123; // declare single instance for MyService class single &#123; MyService() &#125;&#125;class Controller()val myModule = module &#123; // declare factory instance for Controller class factory &#123; Controller() &#125;&#125; 获取注入依赖通过get() 方法获取依赖的对象 1234567891011// Presenter &lt;- Serviceclass Service()class Controller(val view : View)val myModule = module &#123; // declare Service as single instance single &#123; Service() &#125; // declare Controller as single instance, resolving View instance with get() single &#123; Controller(get()) &#125;&#125; 绑定对象类型绑定单个类型 12345678910val myModule = module &#123; // Will match type ServiceImp only single &#123; ServiceImp() &#125; // Will match type Service only single &#123; ServiceImp() as Service &#125; single&lt;Service&gt; &#123; ServiceImp() &#125; &#125; 绑定多个类型(bind) 12345val myModule = module &#123; // Will match types ServiceImp &amp; Service single &#123; ServiceImp() &#125; bind Service::class&#125; 命名用来区分不同的依赖对象 123456val myModule = module &#123; single&lt;Service&gt;(named(\"default\")) &#123; ServiceImpl() &#125; single&lt;Service&gt;(named(\"test\")) &#123; ServiceImpl() &#125;&#125;val service : Service by inject(qualifier = named(\"default\")) 带参的注入1234val myModule = module &#123; single&#123; params -&gt; Presenter(a = params.get(), b = params.get(),c=get()) &#125;&#125;val presenter : Presenter by inject &#123; parametersOf(a, b) &#125; 注：参数最大数量为5 koin componentkoin是依赖注入的容器，koinComponent是直接从koin获取依赖对象的接口。被注入的对象都要实现这个接口。 123456789class MyComponent : KoinComponent &#123; // 懒加载注入 val myService : MyService by inject() // or // 直接注入 val myService : MyService = get()&#125; 1234567interface KoinComponent &#123; /** * Get the associated Koin instance */ fun getKoin(): Koin = KoinPlatformTools.defaultContext().get()&#125; KoinScopeComponent 是KoinComponent的子类，配合scope使用 12345678910interface KoinScopeComponent : KoinComponent &#123; val scope: Scope fun closeScope() &#123; if (scope.isNotClosed()) &#123; scope.close() &#125; &#125;&#125; scopeKoin 提供的一种可以将创建实例绑定生命周期的方式。 12345678module &#123; // 声明作用域 scope&lt;MyType&gt;&#123; // 声明依赖 scoped &#123; Presenter() &#125; // ... &#125;&#125; Scope的定义 Scope name - scope 名称 Scope id - scope 实例的唯一标识 scope&lt;A&gt; { } 、scope(named&lt;A&gt;()){ } 、scope(named(&quot;SCOPE_NAME&quot;)) { } 是等价的，用来定义带有标识的scope, 实际上就是注册了ScopedInstanceFactory Scope 实例工厂。 Scope的使用123456789101112131415class A : KoinScopeComponent &#123; override val scope: Scope by lazy &#123; newScope(this) &#125; // resolve B as inject val b : B by inject() // inject from scope // Resolve B fun doSomething()&#123; val b = get&lt;B&gt;() &#125; fun close()&#123; scope.close() // don't forget to close current scope &#125;&#125; KoinScopeComponent 内调用inject/get ，最终都是通过scope实例去获取注入的对象。所以在KoinScopeComponent外部可以通过scope对象共享依赖。 12345// create scopeval myScope = koin.createScope&lt;A&gt;()// from the same scopeval b = myScope.get&lt;B&gt;() scope 互相关联koin 通过linkTo()连接多少个scope ，实现依赖实例的共享。 12345678910111213141516171819// 定义多个scopemodule &#123; single &#123; A() &#125; // A包含Scope实例 scope&lt;A&gt; &#123; scoped &#123; B() &#125; &#125; scope&lt;B&gt; &#123; scoped &#123; C() &#125; &#125;&#125;// 获取单例val a = koin.get&lt;A&gt;()// 获取scope A 的 B实例val b = a.scope.get&lt;B&gt;()// 连接scopea.scope.linkTo(b.scope)// 获取的C实例相同assertTrue(a.scope.get&lt;C&gt;() == b.scope.get&lt;C&gt;()) TIPS:Android中的应用场景 Activity和Fragment, Fragment和 Fragment之间共享依赖。 ContextKoin 提供了一种context上下文的概念，用来防止依赖冲突, 实现模块间独立的依赖注入。 通常情况下都是通过以下方式初始化Koin 12345// 通过这种方式是创建了一个KoinApplication实例并注册到GlobalContext下startKoin &#123; // declare used modules modules(coffeeAppModule)&#125; 然后KoinComponent 就会使用GlobalContext中的Koin实例来依赖注入。GlobalContext是单例的，是全局的上下文。 通过如下方式创建的KoinApplication 实例不会注册到GlobalContext中，它是独立的个体。所以通过这种方式可以实现组件化DI。 1234567891011121314val myApp = koinApplication &#123; // declare used modules modules(coffeeAppModule)&#125;// 自定义KoinContext 来持有koinApplicationobject MyKoinContext &#123; var koinApp : KoinApplication? = null&#125;MyKoinContext.koinApp = KoinApp// 自定义组件使用MyKoinContext下的Koin对象abstract class CustomKoinComponent : KoinComponent &#123; override fun getKoin(): Koin = MyKoinContext?.koinApp.koin&#125; Koin实现DI api的核心类 类的关系Koin、KoinApplication、KoinContext 是一一对应的关系。 Koin基本实现了所有关键api 。 KoinApplication 实例包含Koin对象，提供了初始化Koin的外部api, 内部逻辑都是委托给Koin来实现。 KoinContext 包含KoinApplication 。 Koin 和 KoinComponent 关系 KoinComponent 内部持有Koin对象。Koin 提供了get() 、inject()方法。KoinComponent委托Koin实现所有DI逻辑。 Koin 和 Scope 关系 Koin 提供了scope 创建、查询、删除api, 所有被创建的scope都会被注册到Koin里。 Koin-AndroidKoin-Android 为了更好的支持Android组件的依赖注入 ,在Koin-core基础上进行了扩展。 初始化Android中初始化koin的方式同样使用startKoin, 额外提供了androidLogger() 和 androidContext() 方法。 123456789101112131415startKoin &#123; // Koin Android logger androidLogger() // 注册Android context androidContext(this@MainApplication) // use modules modules(myAppModules)&#125;// module 中通过androidContext()获取注册的contextval appModule = module &#123; factory &#123; MyPresenter(androidContext().resources.getString(R.string.mystring)) &#125;&#125; 在Android组件中使用KoinKoin-Android 实现了Activity, Fragment, Service组件的KoinComponents扩展，所以可以使用相同的方式注入对象 by inject() - 延迟加载 get() - 直接获取 12345678class DetailActivity : AppCompatActivity() &#123; private val presenter : Presenter by inject() override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) val presenter2:Presenter = get() &#125; Android组件都实现了ComponentCallbacks接口，koin 通过ComponentCallbacks的扩展方法统一实现DI。 123456789101112131415161718inline fun &lt;reified T : Any&gt; ComponentCallbacks.get( qualifier: Qualifier? = null, noinline parameters: ParametersDefinition? = null,): T &#123; return getDefaultScope().get(qualifier, parameters)&#125;fun ComponentCallbacks.getDefaultScope(): Scope = when (this) &#123; is AndroidScopeComponent -&gt; this.scope is KoinScopeComponent -&gt; this.scope else -&gt; getKoin().scopeRegistry.rootScope&#125;fun ComponentCallbacks.getKoin() = when (this) &#123; is KoinComponent -&gt; this.getKoin() else -&gt; GlobalContext.get()&#125; Android Scope同样包含三种类型： single ,factory 和 scope 。前两种使用方式没有区别，下面说说scope的使用方式。 创建ScopeAndroid组件必须实现AndroidScopeComponent 接口提供scope属性的实现。然后scope可以通过如下几个属性代理来创建： activityScope() - 绑定Activity生命周期 activityRetaindScope() - viewModel生命周期 fragmentScope() - 绑定fragment生命周期，并且默认和父层级scope绑定 serviceScope() - Service生命周期 123456class MyActivity : AppCompatActivity, AndroidScopeComponent &#123; // get current Activity's scope override val scope : Scope by activityScope() // MyPresenter is resolved from MyActivity's scope val presenter : MyPresenter by inject()&#125; 定义Scope1234567891011class MyPresenter()class MyAdapter(val presenter : MyPresenter)module &#123; // Declare scope for MyActivity scope&lt;MyActivity&gt; &#123; // get MyPresenter instance from current scope scoped &#123; MyAdapter(get()) &#125; scoped &#123; MyPresenter() &#125; &#125;&#125; 跨页面共享实例首先named定义命名scope 123456module &#123; // Shared user session data scope(named(\"session\")) &#123; scoped &#123; UserSession() &#125; &#125;&#125; 然后在获取实例的之前，创建一个Scope实例并绑定到当前KoinComponent的scope上 123val ourSession = getKoin().createScope(\"ourSession\",named(\"session\")) // 跨页面scopeId scopeName必须相同scope.linkTo(ourSession)val userSession = get&lt;UserSession&gt;() ViewModel注入在acitivity, fragment 或者 service 中注入viewmodel 可以使用如下几种方式： by viewModel() - 懒加载属性代理 getViewModel() - 直接获取实例 12345class DetailActivity : AppCompatActivity() &#123; // Lazy inject ViewModel val detailViewModel: DetailViewModel by viewModel()&#125; 共享 ViewModelViewmodel 实例可以在fragment和它们宿主activity之间共享。 注入同样提供了两种方式: by sharedViewModel() getSharedViewModel() 只需定义一次viewModel, viewmodel定义方式和factory一样。 12345val weatherAppModule = module &#123; // viewModel viewModel &#123; WeatherViewModel(get(), get()) &#125;&#125; Activity 通过 by viewModel 或者 getViewModel提供共享ViewModel实例。Fragments 通过by sharedViewModel()复用。 1234567891011121314151617181920212223class WeatherActivity : AppCompatActivity() &#123; /* * Declare WeatherViewModel with Koin and allow constructor dependency injection */ private val weatherViewModel by viewModel&lt;WeatherViewModel&gt;()&#125;class WeatherHeaderFragment : Fragment() &#123; /* * Declare shared WeatherViewModel with WeatherActivity */ private val weatherViewModel by sharedViewModel&lt;WeatherViewModel&gt;()&#125;class WeatherListFragment : Fragment() &#123; /* * Declare shared WeatherViewModel with WeatherActivity */ private val weatherViewModel by sharedViewModel&lt;WeatherViewModel&gt;()&#125; viewModel状态存储koin 提供了 stateViewModel 方法用来处理SavedStateHandle FragmentFactory通过setupKoinFragmentFactory() 方法替换fragmentFactory,能实现fragment注入。 注册默认koinFactory 123456 startKoin &#123; // setup a KoinFragmentFactory instance fragmentFactory() modules(...)&#125; 定义fragment依赖 123456789class MyFragment(val myService: MyService) : Fragment() &#123;&#125;val appModule = module &#123; single &#123; MyService() &#125; fragment &#123; MyFragment(get()) &#125;&#125; setupKoinFragmentFactory替换framentFactory 12345678910111213141516class MyActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; // Koin Fragment Factory setupKoinFragmentFactory() super.onCreate(savedInstanceState) supportFragmentManager.beginTransaction() .replace&lt;MyFragment&gt;( containerViewId = R.id.mvvm_frame, args = MyBundle(), tag = MyString() ) &#125;&#125; scopeFragment也同样支持scope, 如果要绑定Acitivity的scope 可以使用如下方式： 12345678910111213141516val appModule = module &#123; scope&lt;MyActivity&gt; &#123; fragment &#123; MyFragment(get()) &#125; &#125;&#125;class MyActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; // 添加lifecycleScope setupKoinFragmentFactory(lifecycleScope) super.onCreate(savedInstanceState) //... &#125;&#125; 流程分析简单回顾下Koin的使用方式: 创建modules 提供依赖 startKoin注册modules KoinComponent 中通过get或者inject方法注入依赖的实例。 下面分析下Koin的工作流程： 首先了解下Koin的三个成员变量, 整个流程都是围绕他们来实现的。 ScopeRegistry - 注册Scope工厂 InstanceRegistry - 注册创建实例的工厂(包含Single、Factory、Scope定义的三种工厂) PropertyRegistry - 注册属性的工厂 modulesmodule方法用来创建Module对象。module闭包中的定义，实际上是创建实例的工厂，用来延迟创建实例。 factory, single、scoped 这些Definition都会包裹到InstanceFactory这个实例工厂里。scope 闭包是创建Scope的工厂。这些工厂实例由Module对象持有。 startKoin创建KoinApplication 和 Koin 实例， 并将modules装载到Koin里的。modules中的那些工厂实例都会注册到对应的Registry里。 Koin类还提供了loadModule/unloadModule用来运行时装载和卸载module。 get/injectKoinComponent是我们进行注入的地方，它提供了get和inject扩展方法。其中inject是延迟加载的属性代理方法最终会调用get方法。get源码如下： 12345678inline fun &lt;reified T : Any&gt; KoinComponent.get( qualifier: Qualifier? = null, noinline parameters: ParametersDefinition? = null): T &#123; return if (this is KoinScopeComponent) &#123; scope.get(qualifier, parameters) &#125; else getKoin().get(qualifier, parameters)&#125; 可以看到get有两种情况一种是调用KoinScopeComponnent中scope的get,还有一种是调用koin的get。 12345// koin 的get实现inline fun &lt;reified T : Any&gt; get( qualifier: Qualifier? = null, noinline parameters: ParametersDefinition? = null ): T = scopeRegistry.rootScope.get(qualifier, parameters) 从上面代码可以看到，两种方式最终都是调用scope的get()，区别就是single/factory定义是通过rootScope来注入。 123456789101112131415161718192021222324252627private fun &lt;T&gt; resolveValue( qualifier: Qualifier?, clazz: KClass&lt;*&gt;, instanceContext: InstanceContext, parameterDef: ParametersDefinition? ) = (_koin.instanceRegistry.resolveInstance(qualifier, clazz, this.scopeQualifier, instanceContext) ?: run &#123; _koin.logger.log(Level.DEBUG) &#123; \"'$&#123;clazz.getFullName()&#125;' - q:'$qualifier' look in injected parameters\" &#125; _parameterStack.firstOrNull()?.getOrNull&lt;T&gt;(clazz) &#125; ?: run &#123; _koin.logger.log(Level.DEBUG) &#123; \"'$&#123;clazz.getFullName()&#125;' - q:'$qualifier' look at scope source\" &#125; _source?.let &#123; if (clazz.isInstance(it)) &#123; _source as? T &#125; else null &#125; &#125; ?: run &#123; _koin.logger.log(Level.DEBUG) &#123; \"'$&#123;clazz.getFullName()&#125;' - q:'$qualifier' look in other scopes\" &#125; findInOtherScope&lt;T&gt;(clazz, qualifier, parameterDef) &#125; ?: run &#123; _koin.logger.log(Level.DEBUG) &#123; \"'$&#123;clazz.getFullName()&#125;' - q:'$qualifier' not found\" &#125; _parameterStack.clear() throwDefinitionNotFound(qualifier, clazz) &#125;) 上面是Scope get获取实例的关键方法，可以看到最终还是委托给了InstanceRegistry。 123456789internal fun &lt;T&gt; resolveInstance( qualifier: Qualifier?, clazz: KClass&lt;*&gt;, scopeQualifier: Qualifier, instanceContext: InstanceContext): T? &#123; val indexKey = indexKey(clazz, qualifier, scopeQualifier) return _instances[indexKey]?.get(instanceContext) as? T&#125; 最后查询之前注册的InstanceFactory实例工厂创建依赖的实例。 InstaceFractory 提供了三种实现 ScopedInstanceFactory , FactoryInstanceFactory 和 SingleinstanceFactory 分别对应三种scope类型。","tags":[{"name":"kotlin","slug":"kotlin","permalink":"https://mufans.github.io/tags/kotlin/"},{"name":"IOC","slug":"IOC","permalink":"https://mufans.github.io/tags/IOC/"}]},{"title":"9月学习计划","date":"2021-09-05T10:11:24.000Z","path":"2021/09/05/9月学习计划/","text":"9月学习计划 生命是以时间为单位的，浪费别人的时间等于谋财害命，浪费自己的时间，等于慢性自杀。——鲁迅 书籍 Flutter 开发实战详解 Vue.js 实战 Java 虚拟机规范 深入理解Android java 虚拟机ART C++ Premier CSAPP 课程 Android高手开发课 数据结构之美 设计模式之美 源码学习 Koin 、Hilt – 依赖注入框架 LeakCanary、Matrix、Koom – 内存监控框架 Arouter、Brouter、Drouter – 路由框架","tags":[{"name":"schedule","slug":"schedule","permalink":"https://mufans.github.io/tags/schedule/"}]},{"title":"State生命周期","date":"2021-09-05T07:49:59.000Z","path":"2021/09/05/State生命周期/","text":"Widget生命周期State 是StatefulWidget代理，包含控件构建和生命周期。 State生命周期如下： initState初始化状态，只会调用一次。 didChangeDependenciesinitState之后会调用，当InheritedWidget发生变化时会触发。例如Provide（利用InheritedWidget实现)，监听的数据发生变化时需要更新状态。 build构建控件 setState改变数据通知Widget刷新 didUpdateWidget在setState之后调用，表示控件发生更新 disposeWidget销毁时会调用，只会调用一次，可以用来回收资源。","tags":[{"name":"widget","slug":"widget","permalink":"https://mufans.github.io/tags/widget/"}]},{"title":"dart笔记","date":"2021-09-04T16:07:48.000Z","path":"2021/09/05/dart笔记/","text":"final/const常量声明，const表示编译期常量,final运行时常量。 import导入关键字 1import 'dart:marth' as math 内置数据类型数字类型int 取值范围-2^53 ~2^53 ,double为64位双精度浮点类型。数字类型都是num的子类型。 列表用List或者[]表示 12List list = [1,2,3];var list2= [1,2,...list]; //...表示填充 集合类型用Set或者{}表示 12Set&lt;String&gt; set &#x3D; &#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125;;set.add(&quot;c&quot;); 映射类型用Map或者{}表示 123456Map map &#x3D; &#123; &#39;key&#39;:&#39;value1&#39;, &#39;key2&#39;:&#39;value2&#39;&#125;;map[&#39;key3&#39;] &#x3D; &#39;value3&#39;;String value &#x3D; map[&#39;key&#39;]; 枚举类型 枚举类型不能包含数据成员和方法。 123enum UserType&#123; vip,guest&#125;; 逻辑语句与操作符switch语句支持String 、enum、num等类型 三目运算符 1a?xx:xx 级联操作符 可以对类的成员进行链式调用 12345Event event &#x3D; Event();event ..id &#x3D;1 ..type&#x3D;&quot;&quot; ..name&#x3D;&quot;&quot;; 赋值操作符及空判断操作符 12345678A??&quot;999&quot; &#x2F;&#x2F; A为空返回999AA?? &#x3D; &quot;999&quot; &#x2F;&#x2F; AA为空则赋值&quot;999&quot;AA ~&#x2F; 999 &#x2F;&#x2F; AA对999整除Event event &#x3D; Event();event?.fit(); &#x2F;&#x2F; event不为空调用方法 var 和 dynamicDart是强类型语言。var是编译期语法糖，声明会自动推导出数据类型。dynamic表示动态类型，编译后是一个object类型，到运行时才对类型进行检查。var声明时没制定类型和赋值会被指定为dynamic,到赋值时才推导出类型。 函数方法方法可以省略返回值类型；参数可以不指定类型；命名参数（可选参数）用{}包裹,命名参数必须声明在最后;flutter中自定义控件构造方法的参数比较多，通常只会使用命名参数，然后必传参数用@required注解标识。 123456789func(String username,repoName,&#123;branch = \"master\"&#125;)&#123; &#125;func(\"aaa\",\"ccc\"); // branch默认传masterfunc(\"aaac\",\"bbb\",branch:\"dev\"); // 命名参数必须指定参数名称CustomWidget(&#123;@require String name, Widget child,...&#125;) // require标识必传参数 闭包：方法可以作为参数传递 1234567callback(String text)&#123; return \"aaa\";&#125;do(String calback(String text))&#123; calback(\"ttt\");&#125; 类、接口继承构造函数普通构造函数 1234567891011121314151617181920class Person&#123; String name; int age; String id; Person(String name)&#123; this.name = name; &#125; // 语法糖，成员变量自动赋值 Person(this.name); // 构造函数外部进行赋值，但是外部无法访问this Person(String n,int a):name=n,age=a &#123; &#125; // 重定向 Person(String id):this(\"person\",10,id); Person(this.name,this.age,this.id);&#125; 命名构造函数 12345678910class Person&#123; String name; int age; String id; Person.json(Map m)&#123; this.name = m[\"name\"]; this.age = m[\"age\"]; this.id = m[\"id\"]; &#125;&#125; 工厂构造函数 factory关键字实现工厂构造方法，类似工厂方法模式，一般会将默认构造方法以_开头命名表示私有。工厂构造函数内部无法使用this关键字，类似静态方法。 123456789101112class Person&#123; static final Map&lt;String,Person&gt; _cache = &lt;String,Person&gt;&#123;&#125;; factory Person(name)&#123; if(_cache.containsKey(name)) return _cache[name]; Person p = Person._Internal(name); _cache[name] = p; return p; &#125; Person._Internal(this.name);&#125; 接口dart没有接口关键字，类或者abstarct抽象类可以作为接口，使用implements可以实现多个接口。 12345678910111213141516171819abstarct class Interface&#123; void doA();&#125;class InterfaceClass&#123; void doB();&#125;class Name implements Interface,InterfaceCalss&#123; @override void doA()&#123; &#125; @override void doB()&#123; &#125;&#125; 继承dart只支持单继承，通过extends关键字继承父类, super关键字调用父类 12345678class Base&#123; String name; Base(this.name);&#125;class Child extends Base &#123; Child(name):super(name);&#125; 获取对象类型 通过对象runtimeType返回Type类型对象即当前对象的类型。 is 关键字判断对象的类型, as关键字用来对象转型。 1234Person p = Person();p.runtimeTypep is Personp as Person call( )方法调用: 类内部声明了call方法，可以直接通过对象名称进行call方法的调用；通过typedef声明的方法也可以直接通过funcName.call进行调用。 12345678910111213Class CallTest&#123; call(int i) =&gt; \"$i\";&#125;CallTest callTest = CallTest();callTest.call(1);callTest(1);typedef void MyFunction(int i);MyFunction func = (int i) =&gt; i;func(1);func.call(1); Mixin(混入模式)当类之间不存在继承关系，但是想赋予类另一个通用的行为，可以使用mixin. 使用 with关键字可以添加多个Mixin类. 1234567891011class Musician extends Performer with Musical &#123; // ···&#125;class Maestro extends Person with Musical, Aggressive, Demented &#123; Maestro(String maestroName) &#123; name = maestroName; canConduct = true; &#125;&#125; 通过创建一个继承自 Object 且没有构造函数的类，来 实现 一个 Mixin 。 如果 Mixin 不希望作为常规类被使用，使用关键字 mixin 替换 class 。 123456789101112131415mixin Musical &#123; bool canPlayPiano = false; bool canCompose = false; bool canConduct = false; void entertainMe() &#123; if (canPlayPiano) &#123; print('Playing piano'); &#125; else if (canConduct) &#123; print('Waving hands'); &#125; else &#123; print('Humming to self'); &#125; &#125;&#125; 使用on 关键字可以限制被Mixin的类的父类，声明了父类后，混入类本身相当于继承了该类，可以调用父类的方法 123456789Class Performer&#123; perform();&#125;mixin Musical on Performer&#123; play()&#123; perform(); &#125;&#125; mixin 混入顺序是从右到左，如果多个mixin类同时继承了父类，并且复写了父类的方法，如果方法内部没有调用super方法，调用流程将不会向左继续传递下去。 12345678910111213141516171819202122232425262728293031323334353637383940414243abstract class Base &#123; a()&#123; print(\"base a\"); &#125; b()&#123; print(\"base b\"); &#125;&#125;mixin A on Base &#123; a()&#123; print(\"A a\"); super.a(); &#125; b()&#123; print(\"A b\"); super.b(); &#125;&#125;mixin A2 on Base &#123; a()&#123; print(\"A2 a\"); // super.a(); &#125; b()&#123; print(\"A2 b\"); super.b(); &#125;&#125;class Child extends Base with A,A2&#123; &#125;main()&#123; Child child = Child(); child.a(); // 打印结果: A2 a child.b(); // 打印结果: A2 b -&gt; A b -&gt; base b&#125; 异步调用async/awaitstreamisolate","tags":[{"name":"dart","slug":"dart","permalink":"https://mufans.github.io/tags/dart/"}]},{"title":"gradle 插件调试","date":"2021-08-17T17:52:00.000Z","path":"2021/08/18/gradle/","text":"插件调试步骤 AS分别打开插件的P项目和依赖插件的D项目 插件项目创建remote调试配置 打开D项目编辑依赖插件的gradle Task,填入上次记录的jvm配置，将suspend改为y(执行时task会等待调试项目Attach) 修改suspend 双击该任务执行Task，terminal会提示正在监听端口，任务被挂起。然后，返回P项目打上断点点击调试按钮，发现D项目Task继续执行了，这时表示调试就成功了。 其他方式通过命令行连接调试 修改gradle配置 1export GRADLE_OPTS&#x3D;&quot;-agentlib:jdwp&#x3D;transport&#x3D;dt_socket,server&#x3D;y,suspend&#x3D;y,address&#x3D;5008&quot; 命令行添加如下参数， 1.&#x2F;gradlew clean assembleDebug -Dorg.gradle.debug&#x3D;true --no-daemon 注 经过多次尝试都无法成功，D项目的任务会一直卡死在start daemon无法被调试唤醒。","tags":[{"name":"gradle","slug":"gradle","permalink":"https://mufans.github.io/tags/gradle/"}]}]