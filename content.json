[{"title":"csapp-note-处理器体系结构","date":"2023-11-19T08:04:24.000Z","path":"2023/11/19/csapp-note-处理器体系结构/","text":"指令集体系结构一个处理器支持的指令和指令的字节集编码成为它的指令集体系结构（Instruction-Set Architecture, ISA）。 处理器顺序实现每个时钟周期，SEQ执行处理一条完整指令所需的所有步骤。这种实现需要很长的时钟周期事件，性能很差。现代的处理器都是流水线化的，更加高效。 处理指令的几个组成阶段通常，一条指令包括很多操作。它们被组织成某个特定的阶段序列，所有指令遵循统一的序列。 取指：从内存读取指令字节，地址为pc的值。从指令中抽取指令指示符的两个部分，一般为指令代码和指令功能。 译码：从寄存器文件读入操作数。 执行：算数逻辑单元(ALU)要么执行指令指明的操作，计算内存引用的有效地址，要么增加或减少栈指针。 访存：从内存读写数据。 写回：将结果写到寄存器文件。 更新PC：将Pc设置到下一条指令的地址。 SEQ小结SEQ的问题是效率低。为了使信号能在一个周期内传播所有阶段，时钟必须非常慢。 这种实现方法不能充分利用硬件单元，因为每个单元只在整个时钟周期的一部分时间内才被使用。 流水线的通用原理流水线化的系统中，待执行的任务被划分成若干独立的阶段。通常允许多任务同时经过系统，而不是等到一个任务完成了所有阶段后才开始。 流水线化的一个重要的特性就是提高系统的吞吐量,也就是单位时间内的执行的任务数量, 同时带来的弊端就是会轻微的增加延迟，也就是一个任务所需要的时间。 三级流水线三级流水线分为三个阶段： 取指 从存储器中读取指令 译码 识别指令 执行 执行指令并将结果回写到存储器 PIPE各阶段实现 PC选择和取指阶段 整个阶段必须选择pc的当前值，并且预测下一个PC值。 Pc选择逻辑从三个程序计数器源中进行选择。当一条预测错误的分支进入访存阶段时，会从流水线寄存器A中读取下一条指令地址。当ret指令进入写回阶段时，会从流水线寄存器B中读取返回地址。 其他情况会从流水线寄存器C中获取PC的预测值。 小结流水线设计通过让不同阶段的任务并行操作，改进了系统的吞吐量性能。在任意一个给定的时刻，多条指令被不同的阶段处理。","tags":[{"name":"csapp,操作系统","slug":"csapp-操作系统","permalink":"https://mufans.github.io/tags/csapp-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"Android性能优化总结","date":"2023-10-23T16:47:58.000Z","path":"2023/10/24/AndroidPerf/","text":"Android性能优化Android性能优化分为以下几个大类： 启动速度 内存占用 流畅度 网络 包体积 稳定性治理 启动速度优化 启动速度测量 任务调度优化 虚拟机优化 启动页合并 内存优化 内存泄漏 内存抖动 OOM问题 大图检测 流畅度优化 卡顿检测 布局优化 绘制优化 锁优化 对象池 消息治理 包体积优化 资源缩减、R文件内联、图片压缩 代码混淆、无用代码移除、字节码指令优化 So 动态化、模块插件化 网络优化 Okhttp复用、Gson解析优化 缓存策略 HttpDNS 流量监控 稳定性治理 Java Crash Native Crash ANR","tags":[{"name":"Android","slug":"Android","permalink":"https://mufans.github.io/tags/Android/"},{"name":"Performence","slug":"Performence","permalink":"https://mufans.github.io/tags/Performence/"}]},{"title":"swift学习笔记","date":"2023-10-15T07:16:35.000Z","path":"2023/10/15/swift学习笔记/","text":"Swift 简介Swift 是一种安全、快捷、简洁的现代化编程语言。编译器会负责底层的性能优化和实现，使用swift进行开发只要关注它的高级特性，这对开发者来说是十分友好的。 Swift 使用了现代化的编程模式，用来避免常见的编程错误： 变量使用前必须先初始化 数组会检查越界 整数会检查溢出 可选类型用来处理空类型 自动化内存管理 支持捕获异常 基础语法字符串和字符集合控制流函数Swift 函数非常灵活支持类似C函数的无命名参数和OC的命名参数。 函数的参数可以提供默认值用来简化调用方式。 每个函数都是一个类型，由函数参数和返回值组成。Swift 支持高阶函数特性，函数可以作为其他函数的参数和返回值进行传递，也可以内嵌在其他函数中使用。 函数定义和调用123456func greet(person: String) -&gt; String &#123; let greeting = \"Hello, \" + person + \"!\" return greeting&#125;print(greet(person: \"Anna\")) 函数的参数和返回值参数支持无参数和多参数 无返回值 123func greet(person: String) &#123; print(\"Hello, \\(person)!\")&#125; 多返回值 使用元祖返回多个值 12345678910111213141516func minMax(array: [Int]) -&gt; (min: Int, max: Int) &#123; var currentMin = array[0] var currentMax = array[0] for value in array[1..&lt;array.count] &#123; if value &lt; currentMin &#123; currentMin = value &#125; else if value &gt; currentMax &#123; currentMax = value &#125; &#125; return (currentMin, currentMax)&#125;let bounds = minMax(array: [8, -6, 2, 109, 3, 71])print(\"min is \\(bounds.min) and max is \\(bounds.max)\") 返回可选类型 1234567891011121314151617func minMax(array: [Int]) -&gt; (min: Int, max: Int)? &#123; if array.isEmpty &#123; return nil &#125; var currentMin = array[0] var currentMax = array[0] for value in array[1..&lt;array.count] &#123; if value &lt; currentMin &#123; currentMin = value &#125; else if value &gt; currentMax &#123; currentMax = value &#125; &#125; return (currentMin, currentMax)&#125;let bounds = minMax(array: [8, -6, 2, 109, 3, 71])print(\"min is \\(bounds.min) and max is \\(bounds.max)\") 隐式返回值 单行表达式可省略return,作为隐式返回值 123func greeting(for person: String) -&gt; String &#123; \"Hello, \" + person + \"!\"&#125; 函数参数标签和参数名称 参数名作为函数标签 123func someFunction(firstParameterName: Int, secondParameterName: Int) &#123;&#125;someFunction(firstParameterName: 1, secondParameterName: 2) 自定义标签 1234func greet(person: String, from hometown: String) -&gt; String &#123; return \"Hello \\(person)! Glad you could visit from \\(hometown).\"&#125;print(greet(person: \"Bill\", from: \"Cupertino\")) 忽略标签 123func someFunction(_ firstParameterName: Int, secondParameterName: Int) &#123;&#125;someFunction(1, secondParameterName: 2) 参数默认值 123456func someFunction(parameterWithoutDefault: Int, parameterWithDefault: Int = 12) &#123; // If you omit the second argument when calling this function, then // the value of parameterWithDefault is 12 inside the function body.&#125;someFunction(parameterWithoutDefault: 3, parameterWithDefault: 6) // parameterWithDefault is 6someFunction(parameterWithoutDefault: 4) 无默认值的参数比有默认值的参数重要性高，为了更好的匹配函数，无默认值的参数最好定义在前面。 不定长参数 1234567891011func arithmeticMean(_ numbers: Double...) -&gt; Double &#123; var total: Double = 0 for number in numbers &#123; total += number &#125; return total / Double(numbers.count)&#125;arithmeticMean(1, 2, 3, 4, 5)// returns 3.0, which is the arithmetic mean of these five numbersarithmeticMean(3, 8.25, 18.75)// returns 10.0, which is the arithmetic mean of these three numbers 函数支持多个不定长参数，不定长参数后的第一个参数必须是带标签的参数 in-out 参数 函数参数默认是常量，是无法修改的。使用 inout 关键字定义的参数是可变的。只有变量才能作为inout参数进行传递。使用*&amp;* 符号传参，表示变量的值可以被函数修改，类似C语言的别名。 123456789func swapTwoInts(_ a: inout Int, _ b: inout Int) &#123; let temporaryA = a a = b b = temporaryA&#125;var someInt = 3var anotherInt = 107swapTwoInts(&amp;someInt, &amp;anotherInt) inout参数不能有默认值，不定长参数也不能作为inout参数。 函数类型函数也是一种类型，可以定义函数类型的变量，使用函数对其赋值。 1var mathFunction: (Int, Int) -&gt; Int = addTwoInts 高阶函数特性 函数作为参数 函数作为返回值 1234567func printMathResult(_ mathFunction: (Int, Int) -&gt; Int, _ a: Int, _ b: Int) &#123; print(\"Result: \\(mathFunction(a, b))\")&#125;func chooseStepFunction(backward: Bool) -&gt; (Int) -&gt; Int &#123; return backward ? stepBackward : stepForward&#125; 内嵌函数内嵌函数是在函数内部定义的函数，外部不可访问，但可作为高阶函数的返回值抛出。 12345func chooseStepFunction(backward: Bool) -&gt; (Int) -&gt; Int &#123; func stepForward(input: Int) -&gt; Int &#123; return input + 1 &#125; func stepBackward(input: Int) -&gt; Int &#123; return input - 1 &#125; return backward ? stepBackward : stepForward&#125; 闭包(Closure)闭包是自包含的函数代码块，可以在代码中传递和使用。 闭包可以捕获并存储它定义时上下文的常量和变量。 闭包三种形式： 全局的命名函数，但是不能捕获任何值。 嵌套的命名函数可以捕获它外层函数包含的数值。 闭包表达式是一种匿名的语法简洁的闭包，可以捕获上下文的数值。 闭包表达式语法123&#123; (&lt;#parameters#&gt;) -&gt; &lt;#return type#&gt; in &lt;#statements#&gt;&#125; 123reversedNames = names.sorted(by: &#123; (s1: String, s2: String) -&gt; Bool in return s1 &gt; s2&#125;) 类型推断1reversedNames = names.sorted(by: &#123; s1, s2 in return s1 &gt; s2 &#125; ) 单行表达式隐式返回值1reversedNames = names.sorted(by: &#123; s1, s2 in s1 &gt; s2 &#125; ) 参数名称简写1reversedNames = names.sorted(by: &#123; $0 &gt; $1 &#125; ) 运算符方法1reversedNames = names.sorted(by: &gt;) 尾端闭包123reversedNames = names.sorted() &#123; $0 &gt; $1 &#125;// 唯一参数reversedNames = names.sorted &#123; $0 &gt; $1 &#125; 数值捕获闭包可以捕获上下文的常量和变量，在他的方法体中引用和修改变量的值，即使原作用域内的定义的变量已经销毁了。 12345678910111213141516func makeIncrementer(forIncrement amount: Int) -&gt; () -&gt; Int &#123; var runningTotal = 0 func incrementer() -&gt; Int &#123; runningTotal += amount return runningTotal &#125; return incrementer&#125;let incrementByTen = makeIncrementer(forIncrement: 10)incrementByTen()// returns a value of 10incrementByTen()// returns a value of 20incrementByTen()// returns a value of 30 闭包是引用类型逃逸闭包(Escaping closure)当闭包希望脱离函数的控制，可以使用*@escape* 关键字，这样就可以在函数外部使用。 1234var completionHandlers: [() -&gt; Void] = []func someFunctionWithEscapingClosure(completionHandler: @escaping () -&gt; Void) &#123; completionHandlers.append(completionHandler)&#125; 自动闭包（Autoclosures)使用 @autoclosure 关键字可以将表达式自动转换成闭包 1234func serve(customer customerProvider: @autoclosure () -&gt; String) &#123; print(\"Now serving \\(customerProvider())!\")&#125;serve(customer: customersInLine.remove(at: 0)) 枚举枚举定义 12345678910enum CompassPoint &#123; case north case south case east case west&#125;enum Planet &#123; case mercury, venus, earth, mars, jupiter, saturn, uranus, neptune&#125; 枚举变量赋值 12var directionToHead = CompassPoint.westdirectionToHead = .east switch表达式中的应用 1234567891011directionToHead = .southswitch directionToHead &#123;case .north: print(\"Lots of planets have a north\")case .south: print(\"Watch out for penguins\")case .east: print(\"Where the sun rises\")case .west: print(\"Where the skies are blue\")&#125; 枚举遍历 1234567enum Beverage: CaseIterable &#123; case coffee, tea, juice&#125;let numberOfChoices = Beverage.allCases.countfor beverage in Beverage.allCases &#123; print(beverage)&#125; 关联数值 枚举定义声明关联的数值类型，创建实例时动态传值。 12345enum Barcode &#123; case upc(Int, Int, Int, Int) case qrCode(String)&#125;var productBarcode = Barcode.upc(8, 85909, 51226, 3) 1234567// switch 表达式中接收数值switch productBarcode &#123;case .upc(let numberSystem, let manufacturer, let product, let check): print(\"UPC: \\(numberSystem), \\(manufacturer), \\(product), \\(check).\")case .qrCode(let productCode): print(\"QR code: \\(productCode).\")&#125; 原生数值 原生数值是枚举首次定义时设置的，并且对于每个特定类型都是唯一不可变的。 原生数值包含的类型包括字符串、字符、整形浮点型。 1234567enum ASCIIControlCharacter: Character &#123; case tab = \"\\t\" case lineFeed = \"\\n\" case carriageReturn = \"\\r\"&#125;let tab = ASCIIControlCharacter.tab.rawValue 1234567// 隐式赋值enum Planet: Int &#123; case mercury = 1, venus, earth, mars, jupiter, saturn, uranus, neptune&#125;enum CompassPoint: String &#123; case north, south, east, west&#125; 12// 通过原生数值创建枚举类型实例let possiblePlanet = Planet(rawValue: 7) 枚举递归12345678910111213141516indirect enum ArithmeticExpression &#123; case number(Int) case addition(ArithmeticExpression, ArithmeticExpression) case multiplication(ArithmeticExpression, ArithmeticExpression)&#125;func evaluate(_ expression: ArithmeticExpression) -&gt; Int &#123; switch expression &#123; case let .number(value): return value case let .addition(left, right): return evaluate(left) + evaluate(right) case let .multiplication(left, right): return evaluate(left) * evaluate(right) &#125;&#125; 值类型和引用类型var 或者let 赋值，参数传参时都会触发拷贝。 值类型拷贝的是内存，变量的值发生变化不会互相影响。 引用类型拷贝的是引用，引用的值发生变化会互相影响。 值类型： 基本类型、字符串、集合、枚举底层都是是struct实现的，它们都属于值类型 引用类型： 类对象 COW(写时拷贝)Swift底层代码使用了COW技术对Array、Dict、Set等值类型进行了优化。 Initialization初始化是准备类、结构体或者枚举实例的过程，用来设置属性的初始值或者其他初始化操作。 通过定义initializers 构造器来实现初始化操作，构造器是一个实例的方法，它是没有返回值的。 类型也可以定义 deinitializer 析构器，用来在实例回收前清理数据。 Initializers 构造器构造器在创建类型实例会被调用，最简单的形式是无参的实例方法。 123init()&#123; // 初始化逻辑&#125; 结构体例子 12345678struct Fahrenheit &#123; var temperature: Double init() &#123; temperature = 32.0 &#125;&#125;var f = Fahrenheit()print(\"The default temperature is \\(f.temperature)° Fahrenheit\") 属性默认值属性的初始值可以在构造器里设置，也可以在定义的时候设置默认值。 123struct Fahrenheit &#123; var temperature = 32.0&#125; 自定义初始化参数初始化123456789101112struct Celsius &#123; var temperatureInCelsius: Double init(fromFahrenheit fahrenheit: Double) &#123; temperatureInCelsius = (fahrenheit - 32.0) / 1.8 &#125; init(fromKelvin kelvin: Double) &#123; temperatureInCelsius = kelvin - 273.15 &#125;&#125;let boilingPointOfWater = Celsius(fromFahrenheit: 212.0)// boilingPointOfWater.temperatureInCelsius is 100.0let freezingPointOfWater = Celsius(fromKelvin: 273.15) 参数名称和参数标签构造器和普通的函数一样也可以定义参数名称和参数标签。 12345678910111213141516struct Color &#123; let red, green, blue: Double init(red: Double, green: Double, blue: Double) &#123; self.red = red self.green = green self.blue = blue &#125; init(white: Double) &#123; red = white green = white blue = white &#125;&#125;let magenta = Color(red: 1.0, green: 0.0, blue: 1.0)let halfGray = Color(white: 0.5) 无参数标签12345678910111213struct Celsius &#123; var temperatureInCelsius: Double init(fromFahrenheit fahrenheit: Double) &#123; temperatureInCelsius = (fahrenheit - 32.0) / 1.8 &#125; init(fromKelvin kelvin: Double) &#123; temperatureInCelsius = kelvin - 273.15 &#125; init(_ celsius: Double) &#123; temperatureInCelsius = celsius &#125;&#125;let bodyTemperature = Celsius(37.0) 可选属性类型可选属性默认初始值是nil 1234567891011121314class SurveyQuestion &#123; var text: String var response: String? init(text: String) &#123; self.text = text &#125; func ask() &#123; print(text) &#125;&#125;let cheeseQuestion = SurveyQuestion(text: \"Do you like cheese?\")cheeseQuestion.ask()// Prints \"Do you like cheese?\"cheeseQuestion.response = \"Yes, I do like cheese.\" 常量属性赋值常量属性是不可变的，可以定义默认值也可以在构造器里赋值。 12345678910class SurveyQuestion &#123; let text: String var response: String? init(text: String) &#123; self.text = text &#125; func ask() &#123; print(text) &#125;&#125; 默认构造器结构体和类中，在没有定义构造器时，都有一个隐式的默认构造器用来初始化属性。 123456class ShoppingListItem &#123; var name: String? var quantity = 1 var purchased = false&#125;var item = ShoppingListItem() 结构体成员变量构造器结构体在没有定义构造器时，都有一个默认的成员变量构造器。 1234struct Size &#123; var width = 0.0, height = 0.0&#125;let twoByTwo = Size(width: 2.0, height: 2.0) 当有属性有默认值时，调用构造器可以忽略传参。 123456let zeroByTwo = Size(height: 2.0)print(zeroByTwo.width, zeroByTwo.height)// Prints \"0.0 2.0\"let zeroByZero = Size()print(zeroByZero.width, zeroByZero.height) 构造器委托构造器中调用其他构造器，用来避免重复代码，这种调用方式叫构造器委托。 12345678910111213struct Rect &#123; var origin = Point() var size = Size() init(origin: Point, size: Size) &#123; self.origin = origin self.size = size &#125; init(center: Point, size: Size) &#123; let originX = center.x - (size.width / 2) let originY = center.y - (size.height / 2) self.init(origin: Point(x: originX, y: originY), size: size) &#125;&#125; 类继承和初始化所有类包括它的父类中，属性必须在初始化时赋值。 两种属性赋值构造器： 指定构造器 便利构造器 指定构造器指定构造器就是普通的构造器，只能调用父类的构造器。 123init(&lt;#parameters#&gt;) &#123; &lt;#statements#&gt;&#125; 便利构造器便利构造器用来扩展构造器，可以调用当前类的指定构造器和其他便利构造器。 123convenience init(&lt;#parameters#&gt;) &#123; &lt;#statements#&gt;&#125; 初始化两个阶段阶段1: 调用类中的构造器 为类实例分配内存，此时内存未被初始化。 指定构造器确保所有属性的内存分配以及初始化完成。 指定构造器调用父类的构造器完成父类属性的初始化，父类会继续调用直到继承链顶层的类。 当到达顶层类，此时该类的所有属性都已被赋值，实例的内存也被完全初始化了。 阶段2： 从继承链顶层返回后，每个指定构造器对该实例逐级进行初始化完成。此时构造器可以访问self 并且可以修改属性，访问实例方法。 最后，任意便利构造器就可以访问self并对实例进行扩展。 tips: 类实例初始化属性未初始化完成是无法访问self 属性和方法的，因此便利构造器是无法直接访问self的，必须委托指定构造器完成初始化后才能调用。 构造器继承和复写子类默认不会继承父类的构造器。只有满足特定情况下会自动继承。 子类通过 override 关键字可以复写父类的构造器。 tips： 复写构造器必须使用 super 调用父类构造器。 访问父类的属性，必须在父类构造器之后。 未初始化的属性需要在调用父类构造器之前初始化完成。 便利构造器无法访问父类的构造器, 也无法复写父类的构造器。 如父类只定义了一个同步、无参的指定构造器，并且子类构造器没有访问父类的属性，可以忽略父类构造器的调用，编译器会在构造器结尾隐式的调用。 1234567891011121314151617181920212223class Vehicle &#123; var numberOfWheels = 0 var description: String &#123; return \"\\(numberOfWheels) wheel(s)\" &#125;&#125;class Bicycle: Vehicle &#123; override init() &#123; super.init() numberOfWheels = 2 &#125;&#125;// 未定义构造器，并且属性都有默认值，所以继承父类所有构造器class ShoppingListItem: RecipeIngredient &#123; var purchased = false var description: String &#123; var output = \"\\(quantity) x \\(name)\" output += purchased ? \" ✔\" : \" ✘\" return output &#125;&#125; 如下例子为计算属性复写，以及父类构造方法的隐式调用 12345678910class Hoverboard: Vehicle &#123; var color: String init(color: String) &#123; self.color = color // super.init() implicitly called here &#125; override var description: String &#123; return \"\\(super.description) in a beautiful \\(color)\" &#125;&#125; 自动构造器继承 子类没有定义指定构造器，默认情况下会自动继承父类所有指定构造器。 子类复写父类所有指定构造器，会继承父类所有的便利构造器。 子类通过便利构造器复写父类构造器， 也可以继承父类所有便利构造器。 1234567891011121314151617181920class Food &#123; var name: String init(name: String) &#123; self.name = name &#125; convenience init() &#123; self.init(name: \"[Unnamed]\") &#125;&#125;class RecipeIngredient: Food &#123; var quantity: Int init(name: String, quantity: Int) &#123; self.quantity = quantity super.init(name: name) &#125; override convenience init(name: String) &#123; self.init(name: name, quantity: 1) &#125;&#125; Failable Initializers （可失败的构造器）通过 init? 关键字定义允许初始化失败的构造器，当实例初始化失败时会返回 nil , 可以用来校验初始化参数是否有效。 123456789101112131415161718192021222324struct Animal &#123; let species: String init?(species: String) &#123; if species.isEmpty &#123; return nil &#125; self.species = species &#125;&#125;let someCreature = Animal(species: \"Giraffe\")// someCreature is of type Animal?, not Animalif let giraffe = someCreature &#123; print(\"An animal was initialized with a species of \\(giraffe.species)\")&#125;// Prints \"An animal was initialized with a species of Giraffe\"let anonymousCreature = Animal(species: \"\")// anonymousCreature is of type Animal?, not Animalif anonymousCreature == nil &#123; print(\"The anonymous creature couldn't be initialized\")&#125;// Prints \"The anonymous creature couldn't be initialized\" 枚举的Failable构造器在枚举中使用，可以校验参数是否有效 123456789101112131415161718192021222324252627enum TemperatureUnit &#123; case kelvin, celsius, fahrenheit init?(symbol: Character) &#123; switch symbol &#123; case \"K\": self = .kelvin case \"C\": self = .celsius case \"F\": self = .fahrenheit default: return nil &#125; &#125;&#125;let fahrenheitUnit = TemperatureUnit(symbol: \"F\")if fahrenheitUnit != nil &#123; print(\"This is a defined temperature unit, so initialization succeeded.\")&#125;// Prints \"This is a defined temperature unit, so initialization succeeded.\"let unknownUnit = TemperatureUnit(symbol: \"X\")if unknownUnit == nil &#123; print(\"This isn't a defined temperature unit, so initialization failed.\")&#125;// Prints \"This isn't a defined temperature unit, so initialization failed.\" 自带原始值的枚举默认包含Failable构造器 123456789101112131415enum TemperatureUnit: Character &#123; case kelvin = \"K\", celsius = \"C\", fahrenheit = \"F\"&#125;let fahrenheitUnit = TemperatureUnit(rawValue: \"F\")if fahrenheitUnit != nil &#123; print(\"This is a defined temperature unit, so initialization succeeded.\")&#125;// Prints \"This is a defined temperature unit, so initialization succeeded.\"let unknownUnit = TemperatureUnit(rawValue: \"X\")if unknownUnit == nil &#123; print(\"This isn't a defined temperature unit, so initialization failed.\")&#125;// Prints \"This isn't a defined temperature unit, so initialization failed.\" Failable 构造器的传播failable 构造器可以委托调用当前类或者父类中其他failable构造器，任何一个构造器初始化失败都会导致整个初始化过程立即返回失败。 12345678910111213141516class Product &#123; let name: String init?(name: String) &#123; if name.isEmpty &#123; return nil &#125; self.name = name &#125;&#125;class CartItem: Product &#123; let quantity: Int init?(name: String, quantity: Int) &#123; if quantity &lt; 1 &#123; return nil &#125; self.quantity = quantity super.init(name: name) &#125;&#125; Failable 构造器复写子类可以像普通构造器一样复写父类的Failable 构造器， 也可以用不可失败的构造器复写来确保实例的成功初始化。 12345678910111213141516171819202122232425262728293031class Document &#123; var name: String? // this initializer creates a document with a nil name value init() &#123;&#125; // this initializer creates a document with a nonempty name value init?(name: String) &#123; if name.isEmpty &#123; return nil &#125; self.name = name &#125;&#125;class AutomaticallyNamedDocument: Document &#123; override init() &#123; super.init() self.name = \"[Untitled]\" &#125; override init(name: String) &#123; super.init() if name.isEmpty &#123; self.name = \"[Untitled]\" &#125; else &#123; self.name = name &#125; &#125;&#125;class UntitledDocument: Document &#123; override init() &#123; super.init(name: \"[Untitled]\")! &#125;&#125; Required 构造器在构造器前使用required 修饰符来标识所有子类必须实现这个构造器。 1234567891011class SomeClass &#123; required init() &#123; // initializer implementation goes here &#125;&#125;class SomeSubclass: SomeClass &#123; required init() &#123; // subclass implementation of the required initializer goes here &#125;&#125; 通过闭包或者函数设置属性的默认值1234567class SomeClass &#123; let someProperty: SomeType = &#123; // create a default value for someProperty inside this closure // someValue must be of the same type as SomeType return someValue &#125;()&#125; 闭包执行时，实例的其他部分没有被初始化完成。意味着此时在闭包中不能访问其他属性（包括有默认值的属性), 也不能调用任何实例方法。 Deinitialization使用deinit 定义析构器，析构器在实例被回收前立即执行，用来释放资源。并且析构器是类类型专属的。 析构是如何工作的?Swift 使用 ARC （automatic reference counting) 管理内存，会自动回收不可用的实例对象。当使用一些资源时（例如文件读写、播放器)，我们需要在实例回收前释放，此时可以使用析构器。 123deinit&#123; // release resources &#125; 析构器是自动调用的，不允许直接访问。父类的析构器能被子类继承，并且在子类的析构器末尾调用。 析构器执行时，对象实例还没回收，因此可以访问实例的属性。 Optional Chaining可选链是用来查询访问可选实例的属性，方法，脚本的调用链。如果链中所有节点值都不为空表示调用成功。如果其中有一个节点为空，则会中断调用直接返回 nil 。 12345if let r = a?.b?.method()?.c &#123; print(\"result is \\(r)\");&#125; else &#123; print(\"error\");&#125; 12345if (a?.b = c) != nil &#123; print(\"assign success\");&#125; else &#123; print(\"error\")&#125; ARCSwift 使用 Automatic Reference Counting (ARC) 来追踪和管理app的内存使用情况。ARC会自动回收无用的类实例内存。 引用计数只适用于类类型。结构体和枚举是值类型，不使用引用进行存储和传递。 ARC 如何工作？每当创建类实例时，ARC 会分配内存来存储实例的信息。这块内存会持有这个实例的类型以及属性的相关信息。 当实例对象不可用时，ARC会清理实例占用的内存，此时如果访问实例会造成程序崩溃。 为了确保正在使用的实例不会被回收，ARC会追踪所有当前引用实例的属性，常量和变量。ARC 不会回收被任意存活实例引用的对象实例。 当把一个类实例赋值给属性，常量或者变量时，它们会持有这个实例的强引用，强引用会阻止实例被回收。 ACR 例子1234567891011121314151617181920212223242526272829class Person &#123; let name: String init(name: String) &#123; self.name = name print(\"\\(name) is being initialized\") &#125; deinit &#123; print(\"\\(name) is being deinitialized\") &#125;&#125;var reference1: Person?var reference2: Person?var reference3: Person?reference1 = Person(name: \"John Appleseed\")// Prints \"John Appleseed is being initialized\"reference2 = reference1reference3 = reference1reference1 = nilreference2 = nilreference3 = nil// Prints \"John Appleseed is being deinitialized\" 从上面例子可以看出，ARC 使用了引用计数的方式进行管理，当引用计数为0时，对象实例会被回收。 类实例之间的循环强引用两个类实例持有互相引用会阻止 ARC 回收，导致内存泄漏，这种情况叫做 循环强引用。 12345678910111213141516171819202122class A &#123; let name:String init(name:String) &#123; self.name = name &#125; var b:B? deinit&#123; print(\"\\(name) denit\")&#125;&#125;class B &#123; let name:String init(name:String) &#123; self.name = name &#125; var a:A? deinit&#123; print(\"\\(name) denit\")&#125;&#125;var a:A? = A(\"A\")var b:B? = B(\"B\")a.b = bb.a = aa = nilb = nil// a 和 b 的变量切断了ab对象的强引用，但是 ab 对象各自仍持有对方的强引用，导致内存泄漏。 解决强引用循环问题swift 提供了两种解决方式：weak references 和 unowned references 使用场景： weak references ：引用实例相对当前实例有更短的生命周期，能优先被回收 unowned reference：引用的实例有相同或者更长的生命周期 Weak References弱引用不会强持有引用的实例，因此不会阻止ARC进行回收。 当实例被回收时，ARC会自动把弱引用的值设为nil , 因此弱引用必须是可选类型的变量。 使用 weak 关键字定义弱引用 123456789101112131415161718192021222324class A &#123; let name:String init(name:String) &#123; self.name = name &#125; var b:B? deinit&#123; print(\"\\(name) denit\")&#125;&#125;class B &#123; let name:String init(name:String) &#123; self.name = name &#125; weak var a:A? deinit&#123; print(\"\\(name) denit\")&#125;&#125;var a:A? = A(\"A\")var b:B? = B(\"B\")// a持有b强引用， b持有a弱引用a.b = bb.a = a// a变量切断了A实例强引用，此时A实例只被b实例弱引用持有，A实例能被回收a = nil// b变量切断B实例强引用，由于A实例可被回收，B实例也可被回收b = nil Unowned references无主引用同样也不会强持有引用的实例。用来引用生命周期相同或者更长的实例对象。使用 unowned关键字声明属性或者变量。 和弱引用不同的是，无主引用的对象永远是有值的，ARC不会把引用设置为nil , 因此无主引用一定不是可选类型。 在实例对象被回收后访问无主引用，会抛运行时异常。 123456789101112131415161718192021222324class A &#123; let name:String init(name:String) &#123; self.name = name &#125; var b:B? deinit&#123; print(\"\\(name) denit\")&#125;&#125;class B &#123; let name:String unowned let a:A init(name:String,a:A) &#123; self.name = name self.a = a &#125; deinit&#123; print(\"\\(name) denit\")&#125;&#125;var a:A? = A(\"A\")// a持有A实例强引用， B对象持有A无主引用a.b = B(\"B\",a)// a变量切断了A实例强引用，此时A实例只被B实例无主引用持有，A实例能被回收，B实例没有被强引用也被回收a = nil 闭包的强引用循环当类的属性使用闭包赋值，并且闭包捕获了实例对象，此时就发生了强引用循环。 闭包捕获对象通常是因为在闭包体中访问了self的属性或者方法导致的。 强引用的产生是因为闭包也是引用类型。当把闭包赋值给属性时，属性就持有了闭包的引用。 12345678910111213class A&#123; var name :String =\"A\" var format :()-&gt;String = &#123; return \"name:\\(self.name)\" &#125; deinit&#123; print(\"\\(name) deinit\") &#125;&#125;var a = A()a = nil // 此时A对象和format闭包互相强引用导致内存泄漏 解决闭包强引用循环定义闭包时添加捕获列表即可解决循环引用的问题。 捕获列表包含闭包引用的实例，通过 unowned 和weak关键字进行声明。 闭包有参和无参两种形式： 12345678910lazy var someClosure = &#123; [unowned self, weak delegate = self.delegate] (index: Int, stringToProcess: String) -&gt; String in // closure body goes here&#125;lazy var someClosure = &#123; [unowned self, weak delegate = self.delegate] in // closure body goes here&#125; weak 和 unowned 使用使用场景: Unowned: 闭包和捕获对象的生命周期相同，总是同时被回收。 weak ：闭包捕获的引用对象可能在运行时被ARC回收自动置为nil , 在闭包中是作为可选类型使用。","tags":[]},{"title":"K-Redux","date":"2023-10-14T15:43:09.000Z","path":"2023/10/14/K-Redux/","text":"K-ReduxKotlin redux 状态管理框架 参考前端 Redux 实现的 Kotlin 状态管理框架。 Redux 作为 MVI 架构原型基础 ，提供唯一可信数据源、单向数据流的状态更新以及订阅。 K-Redux 的几大角色： Store 状态容器，可包含多种状态，可作为全局或者局部的状态容器 State 代表状态，Store 对外提供 StateFlow 作为状态的聚合用来进行订阅 Action 对应 Intent 代表意图 Reducer 响应 Action 并更新状态 Middleware 拦截Action, 实现切面逻辑 SingleEvent 则是提供单次事件订阅 Store 构建123456Store.StoreBuilder(initState) // 初始状态.addActionToReducer(createActionToReducer()) // Action 和 Reducer的关系转换.addSingleEventReducer(::reducerToEvent) // Reducer 和 单次Event的转换.addMiddleware(middleware) // 中间件，处理切面逻辑.build() Action To Reducer12345678910111213141516171819202122// 处理登出private fun FlowAction.logoutAction() = filterIsInstance&lt;LoginIntent.Logout&gt;().map &#123; LoginReducer.Logout&#125;// 处理登录private fun FlowAction.loginAction() = filterIsInstance&lt;LoginIntent.RequestLogin&gt;().map &#123; val resp = MockUserRepository.login(it.name, it.pass) if (resp.success) &#123; LoginReducer.Success(it.name, resp.token ?: \"\") &#125; else &#123; LoginReducer.Failure(resp.message ?: \"\") &#125;&#125;// 将Action 转换为Reducerprivate fun createActionToReducer(): FlowAction.() -&gt; Flow&lt;Reducer&lt;LoginState&gt;&gt; &#123; return &#123; // 合并多个Action merge(loginAction(), logoutAction()) &#125; &#125; Reducer to SingleEvent1234567private fun reducerToEvent(reducer: Reducer&lt;LoginState&gt;): Event? &#123; return when (reducer) &#123; is LoginReducer.Success -&gt; LoginEvent.Success is LoginReducer.Failure -&gt; LoginEvent.Failure(reducer.message) else -&gt; null &#125;&#125; Middleware123456class LoginMiddleware : Middleware&lt;LoginState&gt; &#123; override suspend fun handle(store: Store&lt;LoginState&gt;, action: Action): Action &#123; // 拦截Action 处理相关逻辑 return action &#125;&#125; 状态订阅123store.stateFlow.collect() // 订阅状态store.singleEvent.collect() // 订阅事件 结合Android ViewModel使用1234567891011121314151617181920// 继承MviViewModelclass LoginViewModel : MviViewModel&lt;LoginState, LoginIntent, LoginEvent&gt;()// 实现如下三个协议// 意图interface MviIntent : Action// 状态interface MviState : State// 事件interface MviEvent : EventviewModel.dispatch(intent) // 发送意图viewModel.stateFlow.collect() // 订阅状态viewModel.singleEvent.collect() // 订阅事件 路由12345678910111213// 通过实现IRouterContract接口，可实现路由拦截interface IRouterContract&lt;T : State&gt; &#123; val actionToReducer: Flow&lt;Action&gt;.() -&gt; Flow&lt;Reducer&lt;T&gt;&gt; val middleware: Middleware&lt;T&gt;? val singleEventReducer: SingleEventReducer&lt;T&gt;?&#125;StoreBuilder.addRouterContract(contract) // 添加路由协议routeStore.dispatch(routeIntent) // 发送路由请求","tags":[{"name":"Android","slug":"Android","permalink":"https://mufans.github.io/tags/Android/"},{"name":"kotlin","slug":"kotlin","permalink":"https://mufans.github.io/tags/kotlin/"}]},{"title":"flutter路由","date":"2023-01-17T08:34:55.000Z","path":"2023/01/17/flutter路由/","text":"flutter_routerhttps://github.com/mufans/flutter_router 项目地址 为了解决flutter多模块开发跨模块通信以及路由跳转代码耦合的问题，参考Arouter 和 annotation_route 原理，使用build_runner自动生成路由表，模块依赖协议的方式实现的一套轻量级路由框架。 功能 支持flutter原生页面路由传参 支持多模块路由通信 支持自定义路由拦截器 支持简单的依赖注入 架构包含三个模块 jrouter_core 路由核心库 router_generator 路由apt库,解析dart注解生成模板代码 flutter_router_support 扩展路由支持flutter。 说明三个模块依赖关系 runtime:flutter_router_support-&gt;jrouter_core dev:router_generator-&gt;jrouter_core 为什么需要flutter_router_support? 由于dart注解解析使用了反射，并且flutter不支持反射，所以jrouter_core没有依赖flutter sdk. 为了支持flutter路由跳转,单独封装了flutter路由的转换逻辑，因此在初始化时需要配置路由扩展. 使用方式 首先在所有需要路由的package中添加依赖 12345678dependencies: jrouter_core: path: ../jrouter_coredev_dependencies: route_generator: path: ../route_generator build_runner: ^2.1.11 在路由相关的类中添加对应的注解 123456789101112131415161718192021222324252627/// 页面路由@JRoute(path: BaseRoute.secondPage)class SecondPage extends StatefulWidget &#123; const SecondPage(&#123;Key? key&#125;) : super(key: key); @override State&lt;SecondPage&gt; createState() =&gt; _SecondPageState();&#125;/// 协议路由 Protocol实现了IProvider接口（参考Arouter设计，用于区分协议路由和页面路由)@JRoute(path: BaseRoute.protocol)class BizModule1Protocol extends Protocol &#123; @override String getName() &#123; return \"biz_module1\"; &#125;&#125;/// 拦截器@JRouteInterceptor(priority: 100)class AppInterceptor implements JInterceptor &#123; @override void process(RouteOp op, InterceptorHandler handler) &#123; print('jrouter=======$&#123;op.path&#125;'); handler.onNext(op); &#125;&#125; 由于dart apt 只作用于单个package，所以需要为每个package生成一个独立的路由容器来收集该package 内部的路由信息，提供给外部统一调用。 12345678910/// main 模块的路由容器@JRouteRoot()class MainRouteHolder extends IRouteHolder &#123; @override IInterceptorGroup get interceptor =&gt; JRouter$MainRouteHolderInterceptorGroup(); @override IRouteRoot get root =&gt; JRoute$MainRouteHolderRoot();&#125; 然后需要在每个package中执行以下指令（ gen.sh) 1flutter packages pub run build_runner clean &amp;&amp; flutter packages pub run build_runner build --delete-conflicting-outputs 执行完毕后，build_runner 会为我们自动生成.g.dart文件 1234567891011121314151617181920212223class JRouter$BizModule2RouteHolderInterceptorGroup implements IInterceptorGroup &#123; @override void loadInto(Map&lt;int, IRouteFactory&lt;JInterceptor&gt;&gt; interceptorMap) &#123;&#125;&#125;class JRoute$BizModule2RouteHolderRoot implements IRouteRoot &#123; @override void loadInto(Map&lt;String, IRouteGroup&gt; groupMap) &#123; groupMap['biz'] = _JRouter$bizGroup(); &#125;&#125;class _JRouter$bizGroup implements IRouteGroup &#123; @override void loadInto(Map&lt;String, RouteMeta&gt; atlas) &#123; atlas['/biz/secondPage'] = RouteMeta( type: RouteType.nameRoute, path: '/biz/secondPage', group: 'biz', routerFactory: (p) =&gt; SecondPage()); &#125;&#125; 然后需要把IInterceptorGroup 和 IRouteRoot 实现类添加到对应的 IRouteHolder中 路由初始化 12345/// 注册各个模块的路由表JRouter.init([MainRouteHolder(), BizModule1RouteHolder(), BizModule2RouteHolder()]);/// 添加flutter路由扩展JRouter.setHook(flutterRouterHook); 注册页面路由表 123456789101112 /// 初始化时可动态注册本地路由JRouter.register(&#123;\"/\": (_) =&gt; MyHomePage(title: 'Flutter Demo Home Page')&#125;);/// 注册命名路由MaterialApp( title: 'Flutter Demo', theme: ThemeData( primarySwatch: Colors.blue, ), routes: buildRouteMap(), /// 添加路由表 initialRoute: \"/\", ); 至此所有准备工作都完成了。 路由使用方式 12345/// 获取协议接口Protocol? protocol = await JRouter.navigation(BaseRoute.protocol);/// flutter页面跳转,支持传参JRouter.navigation(\"/biz/secondPage\", context: context); 参考项目 Arouter 阿里路由 annotation_route flutter路由","tags":[{"name":"路由","slug":"路由","permalink":"https://mufans.github.io/tags/%E8%B7%AF%E7%94%B1/"}]},{"title":"Hexo指令","date":"2022-02-16T17:11:06.000Z","path":"2022/02/17/Hexo指令/","text":"hexo提供了一些指令，方便我们快速搭建博客和发布文章 初始化项目目 1$ hexo init [folder] folder 为可选参数表示初始化目录，默认为当前目录 新建文章 1$ hexo new [layout] title layout 有三种布局: post (直接发布的文章), draft (文章草稿) , page (新的文章), 分别放在不同路径。 默认为post类型。 layout path draft source/_drafts post source/_posts page source page 创建新页面可以使用如下命令: 1$ hexo new page newPage 执行完会在source下创建newPage目录和index.md,之后就可以访问 https://xx.xx/newPage 主页下的内容了。 draft draft 是文章的草稿，文章在发布前可以先创建草稿 文章预览 1$ hexo server --draft 编辑完成可以后通过 publish 命令发布成 post 文章 1$ hexo publish draft newpage 生成静态页面 1$ hexo generate hexo g 简写 hexo d -g 部署后生成静态页面 启动服务 启动服务本地预览 1$ hexo server hexo s 简写 部署 1$ hexo d hexo d -g 部署生成静态页面 和 hexo -d g 等价","tags":[{"name":"Hexo","slug":"Hexo","permalink":"https://mufans.github.io/tags/Hexo/"}]},{"title":"Flutter笔记","date":"2021-09-18T01:37:18.000Z","path":"2021/09/18/Flutter笔记/","text":"Flutter笔记简介Flutter是谷歌开源的跨平台UI框架，支持移动端，web端，桌面以及嵌入式设备。 Flutter是自带渲染引擎的，可以实现平台无关的页面展示。另外也提供了与平台通信的api，补足UI以外的能力。 Flutter开发语言是Dart，是一种编译型语言。它提供了和js相似的语法糖。 Flutter支持热重载，开发比原生要高效。 框架 Flutter框架由Framework,Engine,Embedder三层组成： Framework - 由Dart语言实现 包含两种UI样式 基础控件框架 布局渲染层：负责布局渲染，布局大小位置计算以及UI的变化 动画、画布绘图、手势支持 底层基础接口 Engine - C/C++ Skia渲染引擎 Dart运行时 Text文字排版引擎 PlatformChannels 原生平台通信接口 Embedder 嵌入层用来实现原生平台的扩展功能。 实现原理Flutter在原生平台相当于一个单页面应用，它需要原生平台提供一个容器。Android和IOS分别提供了Activity和ViewController作为原生页面的容器。 Flutter 会在容器中添加一个FlutterView,用于提供Surface, 然后Enigine层会将Framework的控件通过Skia绘制到Surface上。 Flutter一切皆为widget,通常开发只需要专注Widget层的UI实现就行。 编译产物Flutter编译的产物是可执行的二进制文件，安全性和代码的执行效率相对JS较高。 另外需要注意的是：如果没有重新安装而是始终使用热重载进行开发调试，杀掉进程后app会回退到了上一次安装的状态。发现Debug和Release包的产物不同，怀疑是Flutter为了提高热重载的效率启用了不同的编译方式。 热更新Flutter本身没有提供热更新的能力。但是Android可以尝试通过运行时替换so的方式实现。也有第三方例如淘宝的北海(kraken)框架进行了其他尝试，在上层增加了Js到Flutter的映射，通过更新JsBundle来实现热更新，但同时也带来了一部分性能上的损耗。 环境配置123export PUB_HOSTED_URL=https://pub.flutter-io.cn //国内用户需要设置export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn //国内用户需要设置export PATH=PATH_TO_FLUTTER_GIT_DIRECTORY/flutter/bin:$PATH 依赖库flutter的三方库由pub统一管理，可以在 &lt;www.pub.dev&gt; 上查看。 开发的库或者插件首先要打包上传到pub上，然后就可以在工程的pubspec.yaml文件上配置依赖。 版本号的规则： 版本号前添加”^”表示匹配最近的一个大版本，比如”^0.1.2”将会匹配所有0.x.x的最新库。 pubspec.yaml 配置示例： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374version: 1.0.0+1environment: sdk: \"&gt;=2.12.0 &lt;3.0.0\"dependencies: flutter: sdk: flutter retrofit: 2.0.1 dio: ^4.0.0 shared_preferences: ^2.0.6 cached_network_image: ^3.1.0 provider: ^5.0.0 event_bus: ^2.0.0 # The following adds the Cupertino Icons font to your application. # Use with the CupertinoIcons class for iOS style icons. cupertino_icons: ^1.0.2dev_dependencies: flutter_test: sdk: flutter retrofit_generator: 2.0.1 build_runner: 2.0.1# For information on the generic Dart part of this file, see the# following page: https://dart.dev/tools/pub/pubspec# The following section is specific to Flutter.flutter: # The following line ensures that the Material Icons font is # included with your application, so that you can use the icons in # the material Icons class. uses-material-design: true # To add assets to your application, add an assets section, like this: # assets: # - images/a_dot_burr.jpeg # - images/a_dot_ham.jpeg assets: - images/ # An image asset can refer to one or more resolution-specific \"variants\", see # https://flutter.dev/assets-and-images/#resolution-aware. # For details regarding adding assets from package dependencies, see # https://flutter.dev/assets-and-images/#from-packages # To add custom fonts to your application, add a fonts section here, # in this \"flutter\" section. Each entry in this list should have a # \"family\" key with the font family name, and a \"fonts\" key with a # list giving the asset and other descriptors for the font. For # example: # fonts: # - family: Schyler # fonts: # - asset: fonts/Schyler-Regular.ttf # - asset: fonts/Schyler-Italic.ttf # style: italic # - family: Trajan Pro # fonts: # - asset: fonts/TrajanPro.ttf # - asset: fonts/TrajanPro_Bold.ttf # weight: 700 # # For details regarding fonts from package dependencies, # see https://flutter.dev/custom-fonts/#from-packages 项目脚手架当我们新建一个Flutter工程时，Flutter插件会帮助我们创建一个Demo，里面包含了程序的入口和脚手架。通常我们都是基于这个脚手架进行开发。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798// main 表示程序的入口void main() &#123; // runApp 负责创建App启动页并进行展示 runApp(MyApp());&#125;class MyApp extends StatelessWidget &#123; // This widget is the root of your application. @override Widget build(BuildContext context) &#123; var routes = buildRoute(); // 因为Flutter可以看作一个单页面应用，MyApp作为最底层的父容器，可以说MaterialApp包含了整个app的主题样式 return MaterialApp( title: 'Flutter Demo', // 配置主题样式 theme: ThemeData( primarySwatch: Colors.blue, ), routes: routes, // 配置路由 home: MyHomePage(routes.keys.toList(), title: 'Flutter Demo Home Page'), // 配置首页 ); &#125; Map&lt;String, WidgetBuilder&gt; buildRoute() &#123; return &#123;\"first_widget\": (context) =&gt; FirstWidget()&#125;; &#125;&#125;class MyHomePage extends StatefulWidget &#123; MyHomePage(this.routesName, &#123;Key? key, required this.title&#125;) : super(key: key); final String title; final List&lt;String&gt; routesName; @override _MyHomePageState createState() =&gt; _MyHomePageState();&#125;class _MyHomePageState extends State&lt;MyHomePage&gt; &#123; int _counter = 0; void _incrementCounter() &#123; setState(() &#123; _counter++; &#125;); &#125; @override Widget build(BuildContext context) &#123; // Scaffold是脚手架容器，它包含了导航栏、抽屉、底部Tab布局，悬浮按钮等常用的功能 // 并且MaterialApp必须配合Scaffold使用，所以每个页面的根布局都要基于这个容器来实现。 return Scaffold( appBar: AppBar( title: Text(widget.title), ), body: Center( child: Column( mainAxisAlignment: MainAxisAlignment.center, children: &lt;Widget&gt;[ Text( 'You have pushed the button this many times:', ), Text( '$_counter', style: Theme.of(context).textTheme.headline4, ), Expanded( child: ListView.separated( itemCount: widget.routesName.length, separatorBuilder: (BuildContext context, int index) =&gt; Divider( color: Colors.grey, height: 1, ), itemBuilder: (BuildContext context, int index) &#123; return GestureDetector( onTap: () &#123; Navigator.pushNamed(context, widget.routesName[index]); &#125;, child: Container( color: Colors.white, padding: EdgeInsets.only( left: 15, right: 15, top: 5, bottom: 5), child: Text(widget.routesName[index]))); &#125;)) ], ), ), floatingActionButton: FloatingActionButton( onPressed: _incrementCounter, tooltip: 'Increment', child: Icon(Icons.add), ), // This trailing comma makes auto-formatting nicer for build methods. ); &#125;&#125; WidgetFlutter 一切皆为Widget, 可以说Widget是构成页面点基础。 无状态和有状态控件Flutter 包含两种控件，分别为StatelessWidget 和 StatefulWidget 。开发时需要继承这两个类实现自定义UI，然后进行多层嵌套组成一个完整的页面。同时这也是Flutter的一个诟病，一个复杂的页面通常会包含多层嵌套，必定会增加调试和维护的难度。所以如何封装Widget并且控制好Widget的粒度是Flutter开发最需要考量的问题。 StatelessWidget 表示无状态的控件 ，意思就是这个控件不包含变化的元素，每次都是重新构建。 实现无状态布局，需要通过继承StatelessWidget，在build方法中返回需要渲染的布局。 12345678910class TestStatelessWidget extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return Expanded( child: Container( constraints: BoxConstraints.expand(), color: Colors.blue, child: Center(child: Text(\"I am Stateless\")))); &#125;&#125; StatefulWidget 表示有状态的控件，它是包含State状态的。当数据发生变化时,页面要同步更新。 StatefulWidget 只用来创建State实例，关键在于State的实现。State可以看作是Widget的代理，负责创建布局和业务逻辑的实现。 12345678910111213141516171819202122232425262728class TestStatefulWidget extends StatefulWidget &#123; @override State&lt;StatefulWidget&gt; createState() &#123; return TestStatefulWidgetState(); &#125;&#125;class TestStatefulWidgetState extends State&lt;TestStatefulWidget&gt; &#123; final List&lt;Color&gt; _colors = [Colors.red, Colors.blue]; int _colorPos = 0; @override Widget build(BuildContext context) &#123; return Expanded( child: GestureDetector( onTap: () &#123; setState(() &#123; _colorPos = (_colorPos + 1) % 2; &#125;); &#125;, child: Container( color: _colors[_colorPos], child: Center( child: Text(\"click to change color\"), ), ))); &#125;&#125; State 的生命周期StatefulWidget 生命周期如下所示： 包含下面几种生命周期方法： initState初始化状态，只会调用一次。 didChangeDependenciesinitState之后会调用，当InheritedWidget发生变化时会触发。例如Provide（利用InheritedWidget实现)，监听的数据发生变化时需要更新状态。 build构建控件 setState改变数据通知Widget刷新 didUpdateWidget在setState之后调用，表示控件发生更新 disposeWidget销毁时会调用，只会调用一次，可以用来回收资源。 常用控件Flutter控件分为几种类型：布局容器、滚动控件、单一控件以及脚手架控件。 容器 特性 Container 只有一个子Widget ，默认充满全屏，是一个复合容器，包含padding、margin、color、width、height、decoration等配置； Padding 只有一个Child, 嵌套child 用来设置它的padding Center 只有一个child, 嵌套设置居中效果 Stack 堆叠布局，多个child , 类似framelayout Column 垂直布局，多个child，类似Linearlayout ；包含 maxAxisXX 主轴 和crossAxisXX 副轴属性，用来设置对齐方向和 容器的大小 Row 水平布局，多个child, 类似Linearlayout；包含 maxAxisXX 主轴 和crossAxisXX 副轴属性，用来设置对齐方向和 容器的大小 Expanded 只有一个child 用于在Column和Row中,通过flex设置child的比重，类似Linearlayout的weight Wrap 自动换行 Table 表格布局 Flow 瀑布流布局 CustomMultiChildLayout 自定义布局 SizedBox 包含一个child,用来设置尺寸 ConstraintBox 约束布局 Flutter Widget 都是十分细粒度的，一般布局的对齐方式，边距，尺寸，边框样式等属性都是通过多个控件嵌套组合来实现。Container 作为一个复合的控件，包含了几乎所有的属性，是最常用的容器控件。 滚动布局 特性 ListView 列表，包含多个Child GridView 表格列表，包含多个Child SingleChildScrollView 滚动布局，包含单个Child 单一控件 特性 Text 文本 Image 图片 RichText 富文本 TextField 输入框 TextButton 按钮 脚手架控件 特性 MaterialApp app 顶层主页入口，用来配置主题，路由等 Scaffold 作为独立页面的脚手架容器，提供appbar, snackbar,drawer 等常用配置 AppBar 作为Scaffold的appbar属性来使用，提供导航栏，tabbar等功能。 路由动画图片加载数据持久化网络请求状态管理","tags":[]},{"title":"Koin","date":"2021-09-15T16:25:42.000Z","path":"2021/09/16/Koin/","text":"Koin介绍Koin 是基于kotlin 实现的轻量级依赖注入框架，支持DSL语法调用。 Koin 对比 Dagger/HiltKoin: 利用Kotlin 语言特性(大量使用了扩展方法、属性代理等)实现依赖注入,不会影响编译速度。 由Component、Module、Scope关键元素组成。 支持DSL语法调用,代码结构更加清晰。通过属性代理进行对象注入，在kotlin代码里使用起来相对比较方便。 没有使用到反射，基本无性能影响。 支持kotlin和java 只有运行时才会报错，会导致程序崩溃 Dagger/Hilt: 借助编译时注解KPT 生成模板辅助类实现依赖注入，Hilt 结合 Javasisit/ASM修改字节码省去inject调用。由于使用插件拦截构建流程，会影响编译速度。 由Component、Module、Scope关键元素组成。 使用时强依赖注解，包含各种注解, 部分注解的作用重复。 使用生成的辅助类实现注入，基本无性能影响。 支持kotlin和java 编译时期会报错，可靠性相对较高 Gradle依赖Kotlin 工程 12345678910// Add Maven Central to your repositories if neededrepositories &#123; mavenCentral() &#125;dependencies &#123; // Koin for Kotlin apps compile \"io.insert-koin:koin-core:$koin_version\" // Testing testCompile \"io.insert-koin:koin-test:$koin_version\"&#125; Android 工程 koin-android 依赖 koin-core，发现koin-android-viewmodel无需依赖,最新版本viewmodel部分实现已合入koin-android，所以只需依赖koin-android即可 12345678910// Add Maven Central to your repositories if neededrepositories &#123; mavenCentral() &#125;dependencies &#123; // Koin for Android - Scope feature // include koin-android-scope &amp; koin-android implementation \"io.insert-koin:koin-android:$koin_version\" implementation \"io.insert-koin:koin-android-viewmodel:$koin_version\"&#125; 官方示例以下是kotlin依赖注入的使用方式，Android为了支持四大组件和jetpack在koin-core库上进行了扩展，使用方式大同小异 1234567891011121314151617181920212223242526272829303132333435// 数据模型data class HelloMessage(val message: String = \" hello Koin!\")// 抽象接口interface HelloService &#123; fun hello(): String&#125;// 接口实现类 依赖数据模型class HelloServiceImpl(private val helloMessage: HelloMessage) : HelloService &#123; override fun hello(): String &#123; return \"Hey, $&#123;helloMessage.message&#125;\" &#125;&#125;// 被注入的组件，继承KoinComponentclass HelloApplication : KoinComponent &#123; // 通过属性代理注入HelloService private val helloService by inject&lt;HelloService&gt;() fun hello() = println(helloService.hello())&#125;// 定义Module对象，提供了DSL语法声明依赖的对象val helloModule = module &#123; single &#123; HelloMessage() &#125; single &#123; HelloServiceImpl(get()) as HelloService &#125;&#125;// 启动Koin,添加之前声明的ModulesstartKoin &#123; printLogger() modules(helloModule)&#125;// 然后就能直接使用了HelloApplication().hello() Koin-CoreKoin-Core是Koin的基础库, 提供了Koin完整的api KoinApplicationKoinApplication 实例是Koin容器，它包含了Koin实例，用来配置logger，properties和modules。 DSL语法创建KoinApplication两种方式： koinAppication{} - 创建一个独立的实例，需要自己管理。 startKoin{} - 创建一个实例，并绑定到GlobalContext上，通常是使用这种方式。 示例： 12345startKoin &#123; printLogger() // 日志 properties(mapOf(\"key\" to \"value\")) // 属性 modules(helloModule) // 模块&#125; moduleModule 是提供依赖对象的模块, 内部包含所有依赖对象的工厂。 koin也提供了一种DSL创建方式： 1234567891011121314class ComponentA()class ComponentB(val componentA:ComponentA)val moduleA = module&#123; single&#123;ComponentA()&#125;&#125;val moduleB = module&#123; single(ComponentB(get()))&#125;startKoin&#123; modules(moduleA,moduleB) // 注册多个module&#125; Moudle类 重载了plus操作符 123456789&#x2F;** * Help write list of Modules *&#x2F; operator fun plus(module: Module) &#x3D; listOf(this, module) &#x2F;** * Help write list of Modules *&#x2F; operator fun plus(modules: List&lt;Module&gt;) &#x3D; listOf(this) + modules 1val totalModule = moduleA+moduleB // 拼接多个module 覆盖module 和definition1234567891011121314151617val myModuleA = module &#123; single&lt;Service&gt; &#123; ServiceImp() &#125;&#125;val myModuleB = module &#123; single&lt;Service&gt; &#123; TestServiceImp() &#125;&#125;startKoin &#123; // 默认情况下，后注册的module会覆盖之前的 modules(myModuleA,myModuleB)&#125;startKoin &#123; // 禁止覆盖 allowOverride(false)&#125; Scope definition single - 定义单例 factory - 普通工厂，每次注入都会重新创建对象 scoped - 创建对象与作用域生命周期关联 12345678910111213141516class MyService()val myModule = module &#123; // declare single instance for MyService class single &#123; MyService() &#125;&#125;class Controller()val myModule = module &#123; // declare factory instance for Controller class factory &#123; Controller() &#125;&#125; 获取注入依赖通过get() 方法获取依赖的对象 1234567891011// Presenter &lt;- Serviceclass Service()class Controller(val view : View)val myModule = module &#123; // declare Service as single instance single &#123; Service() &#125; // declare Controller as single instance, resolving View instance with get() single &#123; Controller(get()) &#125;&#125; 绑定对象类型绑定单个类型 12345678910val myModule = module &#123; // Will match type ServiceImp only single &#123; ServiceImp() &#125; // Will match type Service only single &#123; ServiceImp() as Service &#125; single&lt;Service&gt; &#123; ServiceImp() &#125; &#125; 绑定多个类型(bind) 12345val myModule = module &#123; // Will match types ServiceImp &amp; Service single &#123; ServiceImp() &#125; bind Service::class&#125; 命名用来区分不同的依赖对象 123456val myModule = module &#123; single&lt;Service&gt;(named(\"default\")) &#123; ServiceImpl() &#125; single&lt;Service&gt;(named(\"test\")) &#123; ServiceImpl() &#125;&#125;val service : Service by inject(qualifier = named(\"default\")) 带参的注入1234val myModule = module &#123; single&#123; params -&gt; Presenter(a = params.get(), b = params.get(),c=get()) &#125;&#125;val presenter : Presenter by inject &#123; parametersOf(a, b) &#125; 注：参数最大数量为5 koin componentkoin是依赖注入的容器，koinComponent是直接从koin获取依赖对象的接口。被注入的对象都要实现这个接口。 123456789class MyComponent : KoinComponent &#123; // 懒加载注入 val myService : MyService by inject() // or // 直接注入 val myService : MyService = get()&#125; 1234567interface KoinComponent &#123; /** * Get the associated Koin instance */ fun getKoin(): Koin = KoinPlatformTools.defaultContext().get()&#125; KoinScopeComponent 是KoinComponent的子类，配合scope使用 12345678910interface KoinScopeComponent : KoinComponent &#123; val scope: Scope fun closeScope() &#123; if (scope.isNotClosed()) &#123; scope.close() &#125; &#125;&#125; scopeKoin 提供的一种可以将创建实例绑定生命周期的方式。 12345678module &#123; // 声明作用域 scope&lt;MyType&gt;&#123; // 声明依赖 scoped &#123; Presenter() &#125; // ... &#125;&#125; Scope的定义 Scope name - scope 名称 Scope id - scope 实例的唯一标识 scope&lt;A&gt; { } 、scope(named&lt;A&gt;()){ } 、scope(named(&quot;SCOPE_NAME&quot;)) { } 是等价的，用来定义带有标识的scope, 实际上就是注册了ScopedInstanceFactory Scope 实例工厂。 Scope的使用123456789101112131415class A : KoinScopeComponent &#123; override val scope: Scope by lazy &#123; newScope(this) &#125; // resolve B as inject val b : B by inject() // inject from scope // Resolve B fun doSomething()&#123; val b = get&lt;B&gt;() &#125; fun close()&#123; scope.close() // don't forget to close current scope &#125;&#125; KoinScopeComponent 内调用inject/get ，最终都是通过scope实例去获取注入的对象。所以在KoinScopeComponent外部可以通过scope对象共享依赖。 12345// create scopeval myScope = koin.createScope&lt;A&gt;()// from the same scopeval b = myScope.get&lt;B&gt;() scope 互相关联koin 通过linkTo()连接多少个scope ，实现依赖实例的共享。 12345678910111213141516171819// 定义多个scopemodule &#123; single &#123; A() &#125; // A包含Scope实例 scope&lt;A&gt; &#123; scoped &#123; B() &#125; &#125; scope&lt;B&gt; &#123; scoped &#123; C() &#125; &#125;&#125;// 获取单例val a = koin.get&lt;A&gt;()// 获取scope A 的 B实例val b = a.scope.get&lt;B&gt;()// 连接scopea.scope.linkTo(b.scope)// 获取的C实例相同assertTrue(a.scope.get&lt;C&gt;() == b.scope.get&lt;C&gt;()) TIPS:Android中的应用场景 Activity和Fragment, Fragment和 Fragment之间共享依赖。 ContextKoin 提供了一种context上下文的概念，用来防止依赖冲突, 实现模块间独立的依赖注入。 通常情况下都是通过以下方式初始化Koin 12345// 通过这种方式是创建了一个KoinApplication实例并注册到GlobalContext下startKoin &#123; // declare used modules modules(coffeeAppModule)&#125; 然后KoinComponent 就会使用GlobalContext中的Koin实例来依赖注入。GlobalContext是单例的，是全局的上下文。 通过如下方式创建的KoinApplication 实例不会注册到GlobalContext中，它是独立的个体。所以通过这种方式可以实现组件化DI。 1234567891011121314val myApp = koinApplication &#123; // declare used modules modules(coffeeAppModule)&#125;// 自定义KoinContext 来持有koinApplicationobject MyKoinContext &#123; var koinApp : KoinApplication? = null&#125;MyKoinContext.koinApp = KoinApp// 自定义组件使用MyKoinContext下的Koin对象abstract class CustomKoinComponent : KoinComponent &#123; override fun getKoin(): Koin = MyKoinContext?.koinApp.koin&#125; Koin实现DI api的核心类 类的关系Koin、KoinApplication、KoinContext 是一一对应的关系。 Koin基本实现了所有关键api 。 KoinApplication 实例包含Koin对象，提供了初始化Koin的外部api, 内部逻辑都是委托给Koin来实现。 KoinContext 包含KoinApplication 。 Koin 和 KoinComponent 关系 KoinComponent 内部持有Koin对象。Koin 提供了get() 、inject()方法。KoinComponent委托Koin实现所有DI逻辑。 Koin 和 Scope 关系 Koin 提供了scope 创建、查询、删除api, 所有被创建的scope都会被注册到Koin里。 Koin-AndroidKoin-Android 为了更好的支持Android组件的依赖注入 ,在Koin-core基础上进行了扩展。 初始化Android中初始化koin的方式同样使用startKoin, 额外提供了androidLogger() 和 androidContext() 方法。 123456789101112131415startKoin &#123; // Koin Android logger androidLogger() // 注册Android context androidContext(this@MainApplication) // use modules modules(myAppModules)&#125;// module 中通过androidContext()获取注册的contextval appModule = module &#123; factory &#123; MyPresenter(androidContext().resources.getString(R.string.mystring)) &#125;&#125; 在Android组件中使用KoinKoin-Android 实现了Activity, Fragment, Service组件的KoinComponents扩展，所以可以使用相同的方式注入对象 by inject() - 延迟加载 get() - 直接获取 12345678class DetailActivity : AppCompatActivity() &#123; private val presenter : Presenter by inject() override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) val presenter2:Presenter = get() &#125; Android组件都实现了ComponentCallbacks接口，koin 通过ComponentCallbacks的扩展方法统一实现DI。 123456789101112131415161718inline fun &lt;reified T : Any&gt; ComponentCallbacks.get( qualifier: Qualifier? = null, noinline parameters: ParametersDefinition? = null,): T &#123; return getDefaultScope().get(qualifier, parameters)&#125;fun ComponentCallbacks.getDefaultScope(): Scope = when (this) &#123; is AndroidScopeComponent -&gt; this.scope is KoinScopeComponent -&gt; this.scope else -&gt; getKoin().scopeRegistry.rootScope&#125;fun ComponentCallbacks.getKoin() = when (this) &#123; is KoinComponent -&gt; this.getKoin() else -&gt; GlobalContext.get()&#125; Android Scope同样包含三种类型： single ,factory 和 scope 。前两种使用方式没有区别，下面说说scope的使用方式。 创建ScopeAndroid组件必须实现AndroidScopeComponent 接口提供scope属性的实现。然后scope可以通过如下几个属性代理来创建： activityScope() - 绑定Activity生命周期 activityRetaindScope() - viewModel生命周期 fragmentScope() - 绑定fragment生命周期，并且默认和父层级scope绑定 serviceScope() - Service生命周期 123456class MyActivity : AppCompatActivity, AndroidScopeComponent &#123; // get current Activity's scope override val scope : Scope by activityScope() // MyPresenter is resolved from MyActivity's scope val presenter : MyPresenter by inject()&#125; 定义Scope1234567891011class MyPresenter()class MyAdapter(val presenter : MyPresenter)module &#123; // Declare scope for MyActivity scope&lt;MyActivity&gt; &#123; // get MyPresenter instance from current scope scoped &#123; MyAdapter(get()) &#125; scoped &#123; MyPresenter() &#125; &#125;&#125; 跨页面共享实例首先named定义命名scope 123456module &#123; // Shared user session data scope(named(\"session\")) &#123; scoped &#123; UserSession() &#125; &#125;&#125; 然后在获取实例的之前，创建一个Scope实例并绑定到当前KoinComponent的scope上 123val ourSession = getKoin().createScope(\"ourSession\",named(\"session\")) // 跨页面scopeId scopeName必须相同scope.linkTo(ourSession)val userSession = get&lt;UserSession&gt;() ViewModel注入在acitivity, fragment 或者 service 中注入viewmodel 可以使用如下几种方式： by viewModel() - 懒加载属性代理 getViewModel() - 直接获取实例 12345class DetailActivity : AppCompatActivity() &#123; // Lazy inject ViewModel val detailViewModel: DetailViewModel by viewModel()&#125; 共享 ViewModelViewmodel 实例可以在fragment和它们宿主activity之间共享。 注入同样提供了两种方式: by sharedViewModel() getSharedViewModel() 只需定义一次viewModel, viewmodel定义方式和factory一样。 12345val weatherAppModule = module &#123; // viewModel viewModel &#123; WeatherViewModel(get(), get()) &#125;&#125; Activity 通过 by viewModel 或者 getViewModel提供共享ViewModel实例。Fragments 通过by sharedViewModel()复用。 1234567891011121314151617181920212223class WeatherActivity : AppCompatActivity() &#123; /* * Declare WeatherViewModel with Koin and allow constructor dependency injection */ private val weatherViewModel by viewModel&lt;WeatherViewModel&gt;()&#125;class WeatherHeaderFragment : Fragment() &#123; /* * Declare shared WeatherViewModel with WeatherActivity */ private val weatherViewModel by sharedViewModel&lt;WeatherViewModel&gt;()&#125;class WeatherListFragment : Fragment() &#123; /* * Declare shared WeatherViewModel with WeatherActivity */ private val weatherViewModel by sharedViewModel&lt;WeatherViewModel&gt;()&#125; viewModel状态存储koin 提供了 stateViewModel 方法用来处理SavedStateHandle FragmentFactory通过setupKoinFragmentFactory() 方法替换fragmentFactory,能实现fragment注入。 注册默认koinFactory 123456 startKoin &#123; // setup a KoinFragmentFactory instance fragmentFactory() modules(...)&#125; 定义fragment依赖 123456789class MyFragment(val myService: MyService) : Fragment() &#123;&#125;val appModule = module &#123; single &#123; MyService() &#125; fragment &#123; MyFragment(get()) &#125;&#125; setupKoinFragmentFactory替换framentFactory 12345678910111213141516class MyActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; // Koin Fragment Factory setupKoinFragmentFactory() super.onCreate(savedInstanceState) supportFragmentManager.beginTransaction() .replace&lt;MyFragment&gt;( containerViewId = R.id.mvvm_frame, args = MyBundle(), tag = MyString() ) &#125;&#125; scopeFragment也同样支持scope, 如果要绑定Acitivity的scope 可以使用如下方式： 12345678910111213141516val appModule = module &#123; scope&lt;MyActivity&gt; &#123; fragment &#123; MyFragment(get()) &#125; &#125;&#125;class MyActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; // 添加lifecycleScope setupKoinFragmentFactory(lifecycleScope) super.onCreate(savedInstanceState) //... &#125;&#125; 流程分析简单回顾下Koin的使用方式: 创建modules 提供依赖 startKoin注册modules KoinComponent 中通过get或者inject方法注入依赖的实例。 下面分析下Koin的工作流程： 首先了解下Koin的三个成员变量, 整个流程都是围绕他们来实现的。 ScopeRegistry - 注册Scope工厂 InstanceRegistry - 注册创建实例的工厂(包含Single、Factory、Scope定义的三种工厂) PropertyRegistry - 注册属性的工厂 modulesmodule方法用来创建Module对象。module闭包中的定义，实际上是创建实例的工厂，用来延迟创建实例。 factory, single、scoped 这些Definition都会包裹到InstanceFactory这个实例工厂里。scope 闭包是创建Scope的工厂。这些工厂实例由Module对象持有。 startKoin创建KoinApplication 和 Koin 实例， 并将modules装载到Koin里的。modules中的那些工厂实例都会注册到对应的Registry里。 Koin类还提供了loadModule/unloadModule用来运行时装载和卸载module。 get/injectKoinComponent是我们进行注入的地方，它提供了get和inject扩展方法。其中inject是延迟加载的属性代理方法最终会调用get方法。get源码如下： 12345678inline fun &lt;reified T : Any&gt; KoinComponent.get( qualifier: Qualifier? = null, noinline parameters: ParametersDefinition? = null): T &#123; return if (this is KoinScopeComponent) &#123; scope.get(qualifier, parameters) &#125; else getKoin().get(qualifier, parameters)&#125; 可以看到get有两种情况一种是调用KoinScopeComponnent中scope的get,还有一种是调用koin的get。 12345// koin 的get实现inline fun &lt;reified T : Any&gt; get( qualifier: Qualifier? = null, noinline parameters: ParametersDefinition? = null ): T = scopeRegistry.rootScope.get(qualifier, parameters) 从上面代码可以看到，两种方式最终都是调用scope的get()，区别就是single/factory定义是通过rootScope来注入。 123456789101112131415161718192021222324252627private fun &lt;T&gt; resolveValue( qualifier: Qualifier?, clazz: KClass&lt;*&gt;, instanceContext: InstanceContext, parameterDef: ParametersDefinition? ) = (_koin.instanceRegistry.resolveInstance(qualifier, clazz, this.scopeQualifier, instanceContext) ?: run &#123; _koin.logger.log(Level.DEBUG) &#123; \"'$&#123;clazz.getFullName()&#125;' - q:'$qualifier' look in injected parameters\" &#125; _parameterStack.firstOrNull()?.getOrNull&lt;T&gt;(clazz) &#125; ?: run &#123; _koin.logger.log(Level.DEBUG) &#123; \"'$&#123;clazz.getFullName()&#125;' - q:'$qualifier' look at scope source\" &#125; _source?.let &#123; if (clazz.isInstance(it)) &#123; _source as? T &#125; else null &#125; &#125; ?: run &#123; _koin.logger.log(Level.DEBUG) &#123; \"'$&#123;clazz.getFullName()&#125;' - q:'$qualifier' look in other scopes\" &#125; findInOtherScope&lt;T&gt;(clazz, qualifier, parameterDef) &#125; ?: run &#123; _koin.logger.log(Level.DEBUG) &#123; \"'$&#123;clazz.getFullName()&#125;' - q:'$qualifier' not found\" &#125; _parameterStack.clear() throwDefinitionNotFound(qualifier, clazz) &#125;) 上面是Scope get获取实例的关键方法，可以看到最终还是委托给了InstanceRegistry。 123456789internal fun &lt;T&gt; resolveInstance( qualifier: Qualifier?, clazz: KClass&lt;*&gt;, scopeQualifier: Qualifier, instanceContext: InstanceContext): T? &#123; val indexKey = indexKey(clazz, qualifier, scopeQualifier) return _instances[indexKey]?.get(instanceContext) as? T&#125; 最后查询之前注册的InstanceFactory实例工厂创建依赖的实例。 InstaceFractory 提供了三种实现 ScopedInstanceFactory , FactoryInstanceFactory 和 SingleinstanceFactory 分别对应三种scope类型。","tags":[{"name":"kotlin","slug":"kotlin","permalink":"https://mufans.github.io/tags/kotlin/"},{"name":"IOC","slug":"IOC","permalink":"https://mufans.github.io/tags/IOC/"}]},{"title":"9月学习计划","date":"2021-09-05T10:11:24.000Z","path":"2021/09/05/9月学习计划/","text":"9月学习计划 生命是以时间为单位的，浪费别人的时间等于谋财害命，浪费自己的时间，等于慢性自杀。——鲁迅 书籍 Flutter 开发实战详解 Vue.js 实战 Java 虚拟机规范 深入理解Android java 虚拟机ART C++ Premier CSAPP 课程 Android高手开发课 数据结构之美 设计模式之美 源码学习 Koin 、Hilt – 依赖注入框架 LeakCanary、Matrix、Koom – 内存监控框架 Arouter、Brouter、Drouter – 路由框架","tags":[{"name":"schedule","slug":"schedule","permalink":"https://mufans.github.io/tags/schedule/"}]},{"title":"State生命周期","date":"2021-09-05T07:49:59.000Z","path":"2021/09/05/State生命周期/","text":"Widget生命周期State 是StatefulWidget代理，包含控件构建和生命周期。 State生命周期如下： initState初始化状态，只会调用一次。 didChangeDependenciesinitState之后会调用，当InheritedWidget发生变化时会触发。例如Provide（利用InheritedWidget实现)，监听的数据发生变化时需要更新状态。 build构建控件 setState改变数据通知Widget刷新 didUpdateWidget在setState之后调用，表示控件发生更新 disposeWidget销毁时会调用，只会调用一次，可以用来回收资源。","tags":[{"name":"widget","slug":"widget","permalink":"https://mufans.github.io/tags/widget/"}]},{"title":"dart笔记","date":"2021-09-04T16:07:48.000Z","path":"2021/09/05/dart笔记/","text":"final/const常量声明，const表示编译期常量,final运行时常量。 import导入关键字 1import 'dart:marth' as math 内置数据类型数字类型int 取值范围-2^53 ~2^53 ,double为64位双精度浮点类型。数字类型都是num的子类型。 列表用List或者[]表示 12List list = [1,2,3];var list2= [1,2,...list]; //...表示填充 集合类型用Set或者{}表示 12Set&lt;String&gt; set &#x3D; &#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125;;set.add(&quot;c&quot;); 映射类型用Map或者{}表示 123456Map map &#x3D; &#123; &#39;key&#39;:&#39;value1&#39;, &#39;key2&#39;:&#39;value2&#39;&#125;;map[&#39;key3&#39;] &#x3D; &#39;value3&#39;;String value &#x3D; map[&#39;key&#39;]; 枚举类型 枚举类型不能包含数据成员和方法。 123enum UserType&#123; vip,guest&#125;; 逻辑语句与操作符switch语句支持String 、enum、num等类型 三目运算符 1a?xx:xx 级联操作符 可以对类的成员进行链式调用 12345Event event &#x3D; Event();event ..id &#x3D;1 ..type&#x3D;&quot;&quot; ..name&#x3D;&quot;&quot;; 赋值操作符及空判断操作符 12345678A??&quot;999&quot; &#x2F;&#x2F; A为空返回999AA?? &#x3D; &quot;999&quot; &#x2F;&#x2F; AA为空则赋值&quot;999&quot;AA ~&#x2F; 999 &#x2F;&#x2F; AA对999整除Event event &#x3D; Event();event?.fit(); &#x2F;&#x2F; event不为空调用方法 var 和 dynamicDart是强类型语言。var是编译期语法糖，声明会自动推导出数据类型。dynamic表示动态类型，编译后是一个object类型，到运行时才对类型进行检查。var声明时没制定类型和赋值会被指定为dynamic,到赋值时才推导出类型。 函数方法方法可以省略返回值类型；参数可以不指定类型；命名参数（可选参数）用{}包裹,命名参数必须声明在最后;flutter中自定义控件构造方法的参数比较多，通常只会使用命名参数，然后必传参数用@required注解标识。 123456789func(String username,repoName,&#123;branch = \"master\"&#125;)&#123; &#125;func(\"aaa\",\"ccc\"); // branch默认传masterfunc(\"aaac\",\"bbb\",branch:\"dev\"); // 命名参数必须指定参数名称CustomWidget(&#123;@require String name, Widget child,...&#125;) // require标识必传参数 闭包：方法可以作为参数传递 1234567callback(String text)&#123; return \"aaa\";&#125;do(String calback(String text))&#123; calback(\"ttt\");&#125; 类、接口继承构造函数普通构造函数 1234567891011121314151617181920class Person&#123; String name; int age; String id; Person(String name)&#123; this.name = name; &#125; // 语法糖，成员变量自动赋值 Person(this.name); // 构造函数外部进行赋值，但是外部无法访问this Person(String n,int a):name=n,age=a &#123; &#125; // 重定向 Person(String id):this(\"person\",10,id); Person(this.name,this.age,this.id);&#125; 命名构造函数 12345678910class Person&#123; String name; int age; String id; Person.json(Map m)&#123; this.name = m[\"name\"]; this.age = m[\"age\"]; this.id = m[\"id\"]; &#125;&#125; 工厂构造函数 factory关键字实现工厂构造方法，类似工厂方法模式，一般会将默认构造方法以_开头命名表示私有。工厂构造函数内部无法使用this关键字，类似静态方法。 123456789101112class Person&#123; static final Map&lt;String,Person&gt; _cache = &lt;String,Person&gt;&#123;&#125;; factory Person(name)&#123; if(_cache.containsKey(name)) return _cache[name]; Person p = Person._Internal(name); _cache[name] = p; return p; &#125; Person._Internal(this.name);&#125; 接口dart没有接口关键字，类或者abstarct抽象类可以作为接口，使用implements可以实现多个接口。 12345678910111213141516171819abstarct class Interface&#123; void doA();&#125;class InterfaceClass&#123; void doB();&#125;class Name implements Interface,InterfaceCalss&#123; @override void doA()&#123; &#125; @override void doB()&#123; &#125;&#125; 继承dart只支持单继承，通过extends关键字继承父类, super关键字调用父类 12345678class Base&#123; String name; Base(this.name);&#125;class Child extends Base &#123; Child(name):super(name);&#125; 获取对象类型 通过对象runtimeType返回Type类型对象即当前对象的类型。 is 关键字判断对象的类型, as关键字用来对象转型。 1234Person p = Person();p.runtimeTypep is Personp as Person call( )方法调用: 类内部声明了call方法，可以直接通过对象名称进行call方法的调用；通过typedef声明的方法也可以直接通过funcName.call进行调用。 12345678910111213Class CallTest&#123; call(int i) =&gt; \"$i\";&#125;CallTest callTest = CallTest();callTest.call(1);callTest(1);typedef void MyFunction(int i);MyFunction func = (int i) =&gt; i;func(1);func.call(1); Mixin(混入模式)当类之间不存在继承关系，但是想赋予类另一个通用的行为，可以使用mixin. 使用 with关键字可以添加多个Mixin类. 1234567891011class Musician extends Performer with Musical &#123; // ···&#125;class Maestro extends Person with Musical, Aggressive, Demented &#123; Maestro(String maestroName) &#123; name = maestroName; canConduct = true; &#125;&#125; 通过创建一个继承自 Object 且没有构造函数的类，来 实现 一个 Mixin 。 如果 Mixin 不希望作为常规类被使用，使用关键字 mixin 替换 class 。 123456789101112131415mixin Musical &#123; bool canPlayPiano = false; bool canCompose = false; bool canConduct = false; void entertainMe() &#123; if (canPlayPiano) &#123; print('Playing piano'); &#125; else if (canConduct) &#123; print('Waving hands'); &#125; else &#123; print('Humming to self'); &#125; &#125;&#125; 使用on 关键字可以限制被Mixin的类的父类，声明了父类后，混入类本身相当于继承了该类，可以调用父类的方法 123456789Class Performer&#123; perform();&#125;mixin Musical on Performer&#123; play()&#123; perform(); &#125;&#125; mixin 混入顺序是从右到左，如果多个mixin类同时继承了父类，并且复写了父类的方法，如果方法内部没有调用super方法，调用流程将不会向左继续传递下去。 12345678910111213141516171819202122232425262728293031323334353637383940414243abstract class Base &#123; a()&#123; print(\"base a\"); &#125; b()&#123; print(\"base b\"); &#125;&#125;mixin A on Base &#123; a()&#123; print(\"A a\"); super.a(); &#125; b()&#123; print(\"A b\"); super.b(); &#125;&#125;mixin A2 on Base &#123; a()&#123; print(\"A2 a\"); // super.a(); &#125; b()&#123; print(\"A2 b\"); super.b(); &#125;&#125;class Child extends Base with A,A2&#123; &#125;main()&#123; Child child = Child(); child.a(); // 打印结果: A2 a child.b(); // 打印结果: A2 b -&gt; A b -&gt; base b&#125; 异步调用async/awaitstreamisolate","tags":[{"name":"dart","slug":"dart","permalink":"https://mufans.github.io/tags/dart/"}]},{"title":"gradle 插件调试","date":"2021-08-17T17:52:00.000Z","path":"2021/08/18/gradle/","text":"插件调试步骤 AS分别打开插件的P项目和依赖插件的D项目 插件项目创建remote调试配置 打开D项目编辑依赖插件的gradle Task,填入上次记录的jvm配置，将suspend改为y(执行时task会等待调试项目Attach) 双击该任务执行Task，terminal会提示正在监听端口，任务被挂起。然后，返回P项目打上断点点击调试按钮，发现D项目Task继续执行了，这时表示调试就成功了。 其他方式通过命令行连接调试 修改gradle配置 1export GRADLE_OPTS&#x3D;&quot;-agentlib:jdwp&#x3D;transport&#x3D;dt_socket,server&#x3D;y,suspend&#x3D;y,address&#x3D;5008&quot; 命令行添加如下参数， 1.&#x2F;gradlew clean assembleDebug -Dorg.gradle.debug&#x3D;true --no-daemon 注 经过多次尝试都无法成功，D项目的任务会一直卡死在start daemon无法被调试唤醒。","tags":[{"name":"gradle","slug":"gradle","permalink":"https://mufans.github.io/tags/gradle/"}]}]