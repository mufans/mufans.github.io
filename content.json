[{"title":"Koin","date":"2021-09-15T16:25:42.000Z","path":"2021/09/16/Koin/","text":"Koin介绍Koin 是基于kotlin 实现的轻量级依赖注入框架，支持DSL语法调用。 Koin 对比 Dagger/HiltKoin: 利用Kotlin 语言特性(大量使用了扩展方法、属性代理等)实现依赖注入,不会影响编译速度。 由Component、Module、Scope关键元素组成。 支持DSL语法调用,代码结构更加清晰。通过属性代理进行对象注入，在kotlin代码里使用起来相对比较方便。 没有使用到反射，基本无性能影响。 支持kotlin和java 只有运行时才会报错，会导致程序崩溃 Dagger/Hilt: 借助编译时注解KPT 生成模板辅助类实现依赖注入，Hilt 结合 Javasisit/ASM修改字节码省去inject调用。由于使用插件拦截构建流程，会影响编译速度。 由Component、Module、Scope关键元素组成。 使用时强依赖注解，包含各种注解, 部分注解的作用重复。 使用生成的辅助类实现注入，基本无性能影响。 支持kotlin和java 编译时期会报错，可靠性相对较高 Gradle依赖Kotlin 工程 12345678910// Add Maven Central to your repositories if neededrepositories &#123; mavenCentral() &#125;dependencies &#123; // Koin for Kotlin apps compile \"io.insert-koin:koin-core:$koin_version\" // Testing testCompile \"io.insert-koin:koin-test:$koin_version\"&#125; Android 工程 koin-android 依赖 koin-core，发现koin-android-viewmodel无需依赖,最新版本viewmodel部分实现已合入koin-android，所以只需依赖koin-android即可 12345678910// Add Maven Central to your repositories if neededrepositories &#123; mavenCentral() &#125;dependencies &#123; // Koin for Android - Scope feature // include koin-android-scope &amp; koin-android implementation \"io.insert-koin:koin-android:$koin_version\" implementation \"io.insert-koin:koin-android-viewmodel:$koin_version\"&#125; 官方示例以下是kotlin依赖注入的使用方式，Android为了支持四大组件和jetpack在koin-core库上进行了扩展，使用方式大同小异 1234567891011121314151617181920212223242526272829303132333435// 数据模型data class HelloMessage(val message: String = \" hello Koin!\")// 抽象接口interface HelloService &#123; fun hello(): String&#125;// 接口实现类 依赖数据模型class HelloServiceImpl(private val helloMessage: HelloMessage) : HelloService &#123; override fun hello(): String &#123; return \"Hey, $&#123;helloMessage.message&#125;\" &#125;&#125;// 被注入的组件，继承KoinComponentclass HelloApplication : KoinComponent &#123; // 通过属性代理注入HelloService private val helloService by inject&lt;HelloService&gt;() fun hello() = println(helloService.hello())&#125;// 定义Module对象，提供了DSL语法声明依赖的对象val helloModule = module &#123; single &#123; HelloMessage() &#125; single &#123; HelloServiceImpl(get()) as HelloService &#125;&#125;// 启动Koin,添加之前声明的ModulesstartKoin &#123; printLogger() modules(helloModule)&#125;// 然后就能直接使用了HelloApplication().hello() Koin-CoreKoin-Core是Koin的基础库, 提供了Koin完整的api KoinApplicationKoinApplication 实例是Koin容器，它包含了Koin实例，用来配置logger，properties和modules。 DSL语法创建KoinApplication两种方式： koinAppication{} - 创建一个独立的实例，需要自己管理。 startKoin{} - 创建一个实例，并绑定到GlobalContext上，通常是使用这种方式。 示例： 12345startKoin &#123; printLogger() // 日志 properties(mapOf(\"key\" to \"value\")) // 属性 modules(helloModule) // 模块&#125; moduleModule 是提供依赖对象的模块, 内部包含所有依赖对象的工厂。 koin也提供了一种DSL创建方式： 1234567891011121314class ComponentA()class ComponentB(val componentA:ComponentA)val moduleA = module&#123; single&#123;ComponentA()&#125;&#125;val moduleB = module&#123; single(ComponentB(get()))&#125;startKoin&#123; modules(moduleA,moduleB) // 注册多个module&#125; Moudle类 重载了plus操作符 123456789&#x2F;** * Help write list of Modules *&#x2F; operator fun plus(module: Module) &#x3D; listOf(this, module) &#x2F;** * Help write list of Modules *&#x2F; operator fun plus(modules: List&lt;Module&gt;) &#x3D; listOf(this) + modules 1val totalModule = moduleA+moduleB // 拼接多个module 覆盖module 和definition1234567891011121314151617val myModuleA = module &#123; single&lt;Service&gt; &#123; ServiceImp() &#125;&#125;val myModuleB = module &#123; single&lt;Service&gt; &#123; TestServiceImp() &#125;&#125;startKoin &#123; // 默认情况下，后注册的module会覆盖之前的 modules(myModuleA,myModuleB)&#125;startKoin &#123; // 禁止覆盖 allowOverride(false)&#125; Scope definition single - 定义单例 factory - 普通工厂，每次注入都会重新创建对象 scoped - 创建对象与作用域生命周期关联 12345678910111213141516class MyService()val myModule = module &#123; // declare single instance for MyService class single &#123; MyService() &#125;&#125;class Controller()val myModule = module &#123; // declare factory instance for Controller class factory &#123; Controller() &#125;&#125; 获取注入依赖通过get() 方法获取依赖的对象 1234567891011// Presenter &lt;- Serviceclass Service()class Controller(val view : View)val myModule = module &#123; // declare Service as single instance single &#123; Service() &#125; // declare Controller as single instance, resolving View instance with get() single &#123; Controller(get()) &#125;&#125; 绑定对象类型绑定单个类型 12345678910val myModule = module &#123; // Will match type ServiceImp only single &#123; ServiceImp() &#125; // Will match type Service only single &#123; ServiceImp() as Service &#125; single&lt;Service&gt; &#123; ServiceImp() &#125; &#125; 绑定多个类型(bind) 12345val myModule = module &#123; // Will match types ServiceImp &amp; Service single &#123; ServiceImp() &#125; bind Service::class&#125; 命名用来区分不同的依赖对象 123456val myModule = module &#123; single&lt;Service&gt;(named(\"default\")) &#123; ServiceImpl() &#125; single&lt;Service&gt;(named(\"test\")) &#123; ServiceImpl() &#125;&#125;val service : Service by inject(qualifier = named(\"default\")) 带参的注入1234val myModule = module &#123; single&#123; params -&gt; Presenter(a = params.get(), b = params.get(),c=get()) &#125;&#125;val presenter : Presenter by inject &#123; parametersOf(a, b) &#125; 注：参数最大数量为5 koin componentkoin是依赖注入的容器，koinComponent是直接从koin获取依赖对象的接口。被注入的对象都要实现这个接口。 123456789class MyComponent : KoinComponent &#123; // 懒加载注入 val myService : MyService by inject() // or // 直接注入 val myService : MyService = get()&#125; 1234567interface KoinComponent &#123; /** * Get the associated Koin instance */ fun getKoin(): Koin = KoinPlatformTools.defaultContext().get()&#125; KoinScopeComponent 是KoinComponent的子类，配合scope使用 12345678910interface KoinScopeComponent : KoinComponent &#123; val scope: Scope fun closeScope() &#123; if (scope.isNotClosed()) &#123; scope.close() &#125; &#125;&#125; scopeKoin 提供的一种可以将创建实例绑定生命周期的方式。 12345678module &#123; // 声明作用域 scope&lt;MyType&gt;&#123; // 声明依赖 scoped &#123; Presenter() &#125; // ... &#125;&#125; Scope的定义 Scope name - scope 名称 Scope id - scope 实例的唯一标识 scope&lt;A&gt; { } 、scope(named&lt;A&gt;()){ } 、scope(named(&quot;SCOPE_NAME&quot;)) { } 是等价的，用来定义带有标识的scope, 实际上就是注册了ScopedInstanceFactory Scope 实例工厂。 Scope的使用123456789101112131415class A : KoinScopeComponent &#123; override val scope: Scope by lazy &#123; newScope(this) &#125; // resolve B as inject val b : B by inject() // inject from scope // Resolve B fun doSomething()&#123; val b = get&lt;B&gt;() &#125; fun close()&#123; scope.close() // don't forget to close current scope &#125;&#125; KoinScopeComponent 内调用inject/get ，最终都是通过scope实例去获取注入的对象。所以在KoinScopeComponent外部可以通过scope对象共享依赖。 12345// create scopeval myScope = koin.createScope&lt;A&gt;()// from the same scopeval b = myScope.get&lt;B&gt;() scope 互相关联koin 通过linkTo()连接多少个scope ，实现依赖实例的共享。 12345678910111213141516171819// 定义多个scopemodule &#123; single &#123; A() &#125; // A包含Scope实例 scope&lt;A&gt; &#123; scoped &#123; B() &#125; &#125; scope&lt;B&gt; &#123; scoped &#123; C() &#125; &#125;&#125;// 获取单例val a = koin.get&lt;A&gt;()// 获取scope A 的 B实例val b = a.scope.get&lt;B&gt;()// 连接scopea.scope.linkTo(b.scope)// 获取的C实例相同assertTrue(a.scope.get&lt;C&gt;() == b.scope.get&lt;C&gt;()) TIPS:Android中的应用场景 Activity和Fragment, Fragment和 Fragment之间共享依赖。 ContextKoin 提供了一种context上下文的概念，用来防止依赖冲突, 实现模块间独立的依赖注入。 通常情况下都是通过以下方式初始化Koin 12345// 通过这种方式是创建了一个KoinApplication实例并注册到GlobalContext下startKoin &#123; // declare used modules modules(coffeeAppModule)&#125; 然后KoinComponent 就会使用GlobalContext中的Koin实例来依赖注入。GlobalContext是单例的，是全局的上下文。 通过如下方式创建的KoinApplication 实例不会注册到GlobalContext中，它是独立的个体。所以通过这种方式可以实现组件化DI。 1234567891011121314val myApp = koinApplication &#123; // declare used modules modules(coffeeAppModule)&#125;// 自定义KoinContext 来持有koinApplicationobject MyKoinContext &#123; var koinApp : KoinApplication? = null&#125;MyKoinContext.koinApp = KoinApp// 自定义组件使用MyKoinContext下的Koin对象abstract class CustomKoinComponent : KoinComponent &#123; override fun getKoin(): Koin = MyKoinContext?.koinApp.koin&#125; Koin实现DI api的核心类 类的关系Koin、KoinApplication、KoinContext 是一一对应的关系。 Koin基本实现了所有关键api 。 KoinApplication 实例包含Koin对象，提供了初始化Koin的外部api, 内部逻辑都是委托给Koin来实现。 KoinContext 包含KoinApplication 。 Koin 和 KoinComponent 关系 KoinComponent 内部持有Koin对象。Koin 提供了get() 、inject()方法。KoinComponent委托Koin实现所有DI逻辑。 Koin 和 Scope 关系 Koin 提供了scope 创建、查询、删除api, 所有被创建的scope都会被注册到Koin里。 Koin-AndroidKoin-Android 为了更好的支持Android组件的依赖注入 ,在Koin-core基础上进行了扩展。 初始化Android中初始化koin的方式同样使用startKoin, 额外提供了androidLogger() 和 androidContext() 方法。 123456789101112131415startKoin &#123; // Koin Android logger androidLogger() // 注册Android context androidContext(this@MainApplication) // use modules modules(myAppModules)&#125;// module 中通过androidContext()获取注册的contextval appModule = module &#123; factory &#123; MyPresenter(androidContext().resources.getString(R.string.mystring)) &#125;&#125; 在Android组件中使用KoinKoin-Android 实现了Activity, Fragment, Service组件的KoinComponents扩展，所以可以使用相同的方式注入对象 by inject() - 延迟加载 get() - 直接获取 12345678class DetailActivity : AppCompatActivity() &#123; private val presenter : Presenter by inject() override fun onCreate(savedInstanceState: Bundle?) &#123; super.onCreate(savedInstanceState) val presenter2:Presenter = get() &#125; Android组件都实现了ComponentCallbacks接口，koin 通过ComponentCallbacks的扩展方法统一实现DI。 123456789101112131415161718inline fun &lt;reified T : Any&gt; ComponentCallbacks.get( qualifier: Qualifier? = null, noinline parameters: ParametersDefinition? = null,): T &#123; return getDefaultScope().get(qualifier, parameters)&#125;fun ComponentCallbacks.getDefaultScope(): Scope = when (this) &#123; is AndroidScopeComponent -&gt; this.scope is KoinScopeComponent -&gt; this.scope else -&gt; getKoin().scopeRegistry.rootScope&#125;fun ComponentCallbacks.getKoin() = when (this) &#123; is KoinComponent -&gt; this.getKoin() else -&gt; GlobalContext.get()&#125; Android Scope同样包含三种类型： single ,factory 和 scope 。前两种使用方式没有区别，下面说说scope的使用方式。 创建ScopeAndroid组件必须实现AndroidScopeComponent 接口提供scope属性的实现。然后scope可以通过如下几个属性代理来创建： activityScope() - 绑定Activity生命周期 activityRetaindScope() - viewModel生命周期 fragmentScope() - 绑定fragment生命周期，并且默认和父层级scope绑定 serviceScope() - Service生命周期 123456class MyActivity : AppCompatActivity, AndroidScopeComponent &#123; // get current Activity's scope override val scope : Scope by activityScope() // MyPresenter is resolved from MyActivity's scope val presenter : MyPresenter by inject()&#125; 定义Scope1234567891011class MyPresenter()class MyAdapter(val presenter : MyPresenter)module &#123; // Declare scope for MyActivity scope&lt;MyActivity&gt; &#123; // get MyPresenter instance from current scope scoped &#123; MyAdapter(get()) &#125; scoped &#123; MyPresenter() &#125; &#125;&#125; 跨页面共享实例首先named定义命名scope 123456module &#123; // Shared user session data scope(named(\"session\")) &#123; scoped &#123; UserSession() &#125; &#125;&#125; 然后在获取实例的之前，创建一个Scope实例并绑定到当前KoinComponent的scope上 123val ourSession = getKoin().createScope(\"ourSession\",named(\"session\")) // 跨页面scopeId scopeName必须相同scope.linkTo(ourSession)val userSession = get&lt;UserSession&gt;() ViewModel注入在acitivity, fragment 或者 service 中注入viewmodel 可以使用如下几种方式： by viewModel() - 懒加载属性代理 getViewModel() - 直接获取实例 12345class DetailActivity : AppCompatActivity() &#123; // Lazy inject ViewModel val detailViewModel: DetailViewModel by viewModel()&#125; 共享 ViewModelViewmodel 实例可以在fragment和它们宿主activity之间共享。 注入同样提供了两种方式: by sharedViewModel() getSharedViewModel() 只需定义一次viewModel, viewmodel定义方式和factory一样。 12345val weatherAppModule = module &#123; // viewModel viewModel &#123; WeatherViewModel(get(), get()) &#125;&#125; Activity 通过 by viewModel 或者 getViewModel提供共享ViewModel实例。Fragments 通过by sharedViewModel()复用。 1234567891011121314151617181920212223class WeatherActivity : AppCompatActivity() &#123; /* * Declare WeatherViewModel with Koin and allow constructor dependency injection */ private val weatherViewModel by viewModel&lt;WeatherViewModel&gt;()&#125;class WeatherHeaderFragment : Fragment() &#123; /* * Declare shared WeatherViewModel with WeatherActivity */ private val weatherViewModel by sharedViewModel&lt;WeatherViewModel&gt;()&#125;class WeatherListFragment : Fragment() &#123; /* * Declare shared WeatherViewModel with WeatherActivity */ private val weatherViewModel by sharedViewModel&lt;WeatherViewModel&gt;()&#125; viewModel状态存储koin 提供了 stateViewModel 方法用来处理SavedStateHandle FragmentFactory通过setupKoinFragmentFactory() 方法替换fragmentFactory,能实现fragment注入。 注册默认koinFactory 123456 startKoin &#123; // setup a KoinFragmentFactory instance fragmentFactory() modules(...)&#125; 定义fragment依赖 123456789class MyFragment(val myService: MyService) : Fragment() &#123;&#125;val appModule = module &#123; single &#123; MyService() &#125; fragment &#123; MyFragment(get()) &#125;&#125; setupKoinFragmentFactory替换framentFactory 12345678910111213141516class MyActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; // Koin Fragment Factory setupKoinFragmentFactory() super.onCreate(savedInstanceState) supportFragmentManager.beginTransaction() .replace&lt;MyFragment&gt;( containerViewId = R.id.mvvm_frame, args = MyBundle(), tag = MyString() ) &#125;&#125; scopeFragment也同样支持scope, 如果要绑定Acitivity的scope 可以使用如下方式： 12345678910111213141516val appModule = module &#123; scope&lt;MyActivity&gt; &#123; fragment &#123; MyFragment(get()) &#125; &#125;&#125;class MyActivity : AppCompatActivity() &#123; override fun onCreate(savedInstanceState: Bundle?) &#123; // 添加lifecycleScope setupKoinFragmentFactory(lifecycleScope) super.onCreate(savedInstanceState) //... &#125;&#125; 流程分析简单回顾下Koin的使用方式: 创建modules 提供依赖 startKoin注册modules KoinComponent 中通过get或者inject方法注入依赖的实例。 下面分析下Koin的工作流程： 首先了解下Koin的三个成员变量, 整个流程都是围绕他们来实现的。 ScopeRegistry - 注册Scope工厂 InstanceRegistry - 注册创建实例的工厂(包含Single、Factory、Scope定义的三种工厂) PropertyRegistry - 注册属性的工厂 modulesmodule方法用来创建Module对象。module闭包中的定义，实际上是创建实例的工厂，用来延迟创建实例。 factory, single、scoped 这些Definition都会包裹到InstanceFactory这个实例工厂里。scope 闭包是创建Scope的工厂。这些工厂实例由Module对象持有。 startKoin创建KoinApplication 和 Koin 实例， 并将modules装载到Koin里的。modules中的那些工厂实例都会注册到对应的Registry里。 Koin类还提供了loadModule/unloadModule用来运行时装载和卸载module。 get/injectKoinComponent是我们进行注入的地方，它提供了get和inject扩展方法。其中inject是延迟加载的属性代理方法最终会调用get方法。get源码如下： 12345678inline fun &lt;reified T : Any&gt; KoinComponent.get( qualifier: Qualifier? = null, noinline parameters: ParametersDefinition? = null): T &#123; return if (this is KoinScopeComponent) &#123; scope.get(qualifier, parameters) &#125; else getKoin().get(qualifier, parameters)&#125; 可以看到get有两种情况一种是调用KoinScopeComponnent中scope的get,还有一种是调用koin的get。 12345// koin 的get实现inline fun &lt;reified T : Any&gt; get( qualifier: Qualifier? = null, noinline parameters: ParametersDefinition? = null ): T = scopeRegistry.rootScope.get(qualifier, parameters) 从上面代码可以看到，两种方式最终都是调用scope的get()，区别就是single/factory定义是通过rootScope来注入。 123456789101112131415161718192021222324252627private fun &lt;T&gt; resolveValue( qualifier: Qualifier?, clazz: KClass&lt;*&gt;, instanceContext: InstanceContext, parameterDef: ParametersDefinition? ) = (_koin.instanceRegistry.resolveInstance(qualifier, clazz, this.scopeQualifier, instanceContext) ?: run &#123; _koin.logger.log(Level.DEBUG) &#123; \"'$&#123;clazz.getFullName()&#125;' - q:'$qualifier' look in injected parameters\" &#125; _parameterStack.firstOrNull()?.getOrNull&lt;T&gt;(clazz) &#125; ?: run &#123; _koin.logger.log(Level.DEBUG) &#123; \"'$&#123;clazz.getFullName()&#125;' - q:'$qualifier' look at scope source\" &#125; _source?.let &#123; if (clazz.isInstance(it)) &#123; _source as? T &#125; else null &#125; &#125; ?: run &#123; _koin.logger.log(Level.DEBUG) &#123; \"'$&#123;clazz.getFullName()&#125;' - q:'$qualifier' look in other scopes\" &#125; findInOtherScope&lt;T&gt;(clazz, qualifier, parameterDef) &#125; ?: run &#123; _koin.logger.log(Level.DEBUG) &#123; \"'$&#123;clazz.getFullName()&#125;' - q:'$qualifier' not found\" &#125; _parameterStack.clear() throwDefinitionNotFound(qualifier, clazz) &#125;) 上面是Scope get获取实例的关键方法，可以看到最终还是委托给了InstanceRegistry。 123456789internal fun &lt;T&gt; resolveInstance( qualifier: Qualifier?, clazz: KClass&lt;*&gt;, scopeQualifier: Qualifier, instanceContext: InstanceContext): T? &#123; val indexKey = indexKey(clazz, qualifier, scopeQualifier) return _instances[indexKey]?.get(instanceContext) as? T&#125; 最后查询之前注册的InstanceFactory实例工厂创建依赖的实例。 InstaceFractory 提供了三种实现 ScopedInstanceFactory , FactoryInstanceFactory 和 SingleinstanceFactory 分别对应三种scope类型。","tags":[{"name":"kotlin","slug":"kotlin","permalink":"https://mufans.github.io/tags/kotlin/"},{"name":"IOC","slug":"IOC","permalink":"https://mufans.github.io/tags/IOC/"}]},{"title":"9月学习计划","date":"2021-09-05T10:11:24.000Z","path":"2021/09/05/9月学习计划/","text":"9月学习计划 生命是以时间为单位的，浪费别人的时间等于谋财害命，浪费自己的时间，等于慢性自杀。——鲁迅 书籍 Flutter 开发实战详解 Vue.js 实战 Java 虚拟机规范 深入理解Android java 虚拟机ART C++ Premier CSAPP 课程 Android高手开发课 数据结构之美 设计模式之美 源码学习 Koin 、Hilt – 依赖注入框架 LeakCanary、Matrix、Koom – 内存监控框架 Arouter、Brouter、Drouter – 路由框架","tags":[{"name":"schedule","slug":"schedule","permalink":"https://mufans.github.io/tags/schedule/"}]},{"title":"State生命周期","date":"2021-09-05T07:49:59.000Z","path":"2021/09/05/State生命周期/","text":"Widget生命周期State 是StatefulWidget代理，包含控件构建和生命周期。 State生命周期如下： initState初始化状态，只会调用一次。 didChangeDependenciesinitState之后会调用，当InheritedWidget发生变化时会触发。例如Provide（利用InheritedWidget实现)，监听的数据发生变化时需要更新状态。 build构建控件 setState改变数据通知Widget刷新 didUpdateWidget在setState之后调用，表示控件发生更新 disposeWidget销毁时会调用，只会调用一次，可以用来回收资源。","tags":[{"name":"widget","slug":"widget","permalink":"https://mufans.github.io/tags/widget/"}]},{"title":"dart笔记","date":"2021-09-04T16:07:48.000Z","path":"2021/09/05/dart笔记/","text":"final/const常量声明，const表示编译期常量,final运行时常量。 import导入关键字 1import 'dart:marth' as math 内置数据类型数字类型int 取值范围-2^53 ~2^53 ,double为64位双精度浮点类型。数字类型都是num的子类型。 列表用List或者[]表示 12List list = [1,2,3];var list2= [1,2,...list]; //...表示填充 集合类型用Set或者{}表示 12Set&lt;String&gt; set &#x3D; &#123;&quot;a&quot;,&quot;b&quot;,&quot;c&quot;&#125;;set.add(&quot;c&quot;); 映射类型用Map或者{}表示 123456Map map &#x3D; &#123; &#39;key&#39;:&#39;value1&#39;, &#39;key2&#39;:&#39;value2&#39;&#125;;map[&#39;key3&#39;] &#x3D; &#39;value3&#39;;String value &#x3D; map[&#39;key&#39;]; 枚举类型 枚举类型不能包含数据成员和方法。 123enum UserType&#123; vip,guest&#125;; 逻辑语句与操作符switch语句支持String 、enum、num等类型 三目运算符 1a?xx:xx 级联操作符 可以对类的成员进行链式调用 12345Event event &#x3D; Event();event ..id &#x3D;1 ..type&#x3D;&quot;&quot; ..name&#x3D;&quot;&quot;; 赋值操作符及空判断操作符 12345678A??&quot;999&quot; &#x2F;&#x2F; A为空返回999AA?? &#x3D; &quot;999&quot; &#x2F;&#x2F; AA为空则赋值&quot;999&quot;AA ~&#x2F; 999 &#x2F;&#x2F; AA对999整除Event event &#x3D; Event();event?.fit(); &#x2F;&#x2F; event不为空调用方法 var 和 dynamicDart是强类型语言。var是编译期语法糖，声明会自动推导出数据类型。dynamic表示动态类型，编译后是一个object类型，到运行时才对类型进行检查。var声明时没制定类型和赋值会被指定为dynamic,到赋值时才推导出类型。 函数方法方法可以省略返回值类型；参数可以不指定类型；命名参数（可选参数）用{}包裹,命名参数必须声明在最后;flutter中自定义控件构造方法的参数比较多，通常只会使用命名参数，然后必传参数用@required注解标识。 123456789func(String username,repoName,&#123;branch = \"master\"&#125;)&#123; &#125;func(\"aaa\",\"ccc\"); // branch默认传masterfunc(\"aaac\",\"bbb\",branch:\"dev\"); // 命名参数必须指定参数名称CustomWidget(&#123;@require String name, Widget child,...&#125;) // require标识必传参数 闭包：方法可以作为参数传递 1234567callback(String text)&#123; return \"aaa\";&#125;do(String calback(String text))&#123; calback(\"ttt\");&#125; 类、接口继承构造函数普通构造函数 1234567891011121314151617181920class Person&#123; String name; int age; String id; Person(String name)&#123; this.name = name; &#125; // 语法糖，成员变量自动赋值 Person(this.name); // 构造函数外部进行赋值，但是外部无法访问this Person(String n,int a):name=n,age=a &#123; &#125; // 重定向 Person(String id):this(\"person\",10,id); Person(this.name,this.age,this.id);&#125; 命名构造函数 12345678910class Person&#123; String name; int age; String id; Person.json(Map m)&#123; this.name = m[\"name\"]; this.age = m[\"age\"]; this.id = m[\"id\"]; &#125;&#125; 工厂构造函数 factory关键字实现工厂构造方法，类似工厂方法模式，一般会将默认构造方法以_开头命名表示私有。工厂构造函数内部无法使用this关键字，类似静态方法。 123456789101112class Person&#123; static final Map&lt;String,Person&gt; _cache = &lt;String,Person&gt;&#123;&#125;; factory Person(name)&#123; if(_cache.containsKey(name)) return _cache[name]; Person p = Person._Internal(name); _cache[name] = p; return p; &#125; Person._Internal(this.name);&#125; 接口dart没有接口关键字，类或者abstarct抽象类可以作为接口，使用implements可以实现多个接口。 12345678910111213141516171819abstarct class Interface&#123; void doA();&#125;class InterfaceClass&#123; void doB();&#125;class Name implements Interface,InterfaceCalss&#123; @override void doA()&#123; &#125; @override void doB()&#123; &#125;&#125; 继承dart只支持单继承，通过extends关键字继承父类, super关键字调用父类 12345678class Base&#123; String name; Base(this.name);&#125;class Child extends Base &#123; Child(name):super(name);&#125; 获取对象类型 通过对象runtimeType返回Type类型对象即当前对象的类型。 is 关键字判断对象的类型, as关键字用来对象转型。 1234Person p = Person();p.runtimeTypep is Personp as Person call( )方法调用: 类内部声明了call方法，可以直接通过对象名称进行call方法的调用；通过typedef声明的方法也可以直接通过funcName.call进行调用。 12345678910111213Class CallTest&#123; call(int i) =&gt; \"$i\";&#125;CallTest callTest = CallTest();callTest.call(1);callTest(1);typedef void MyFunction(int i);MyFunction func = (int i) =&gt; i;func(1);func.call(1); Mixin(混入模式)当类之间不存在继承关系，但是想赋予类另一个通用的行为，可以使用mixin. 使用 with关键字可以添加多个Mixin类. 1234567891011class Musician extends Performer with Musical &#123; // ···&#125;class Maestro extends Person with Musical, Aggressive, Demented &#123; Maestro(String maestroName) &#123; name = maestroName; canConduct = true; &#125;&#125; 通过创建一个继承自 Object 且没有构造函数的类，来 实现 一个 Mixin 。 如果 Mixin 不希望作为常规类被使用，使用关键字 mixin 替换 class 。 123456789101112131415mixin Musical &#123; bool canPlayPiano = false; bool canCompose = false; bool canConduct = false; void entertainMe() &#123; if (canPlayPiano) &#123; print('Playing piano'); &#125; else if (canConduct) &#123; print('Waving hands'); &#125; else &#123; print('Humming to self'); &#125; &#125;&#125; 使用on 关键字可以限制被Mixin的类的父类，声明了父类后，混入类本身相当于继承了该类，可以调用父类的方法 123456789Class Performer&#123; perform();&#125;mixin Musical on Performer&#123; play()&#123; perform(); &#125;&#125; mixin 混入顺序是从右到左，如果多个mixin类同时继承了父类，并且复写了父类的方法，如果方法内部没有调用super方法，调用流程将不会向左继续传递下去。 12345678910111213141516171819202122232425262728293031323334353637383940414243abstract class Base &#123; a()&#123; print(\"base a\"); &#125; b()&#123; print(\"base b\"); &#125;&#125;mixin A on Base &#123; a()&#123; print(\"A a\"); super.a(); &#125; b()&#123; print(\"A b\"); super.b(); &#125;&#125;mixin A2 on Base &#123; a()&#123; print(\"A2 a\"); // super.a(); &#125; b()&#123; print(\"A2 b\"); super.b(); &#125;&#125;class Child extends Base with A,A2&#123; &#125;main()&#123; Child child = Child(); child.a(); // 打印结果: A2 a child.b(); // 打印结果: A2 b -&gt; A b -&gt; base b&#125; 异步调用async/awaitstreamisolate","tags":[{"name":"dart","slug":"dart","permalink":"https://mufans.github.io/tags/dart/"}]},{"title":"gradle 插件调试","date":"2021-08-17T17:52:00.000Z","path":"2021/08/18/gradle/","text":"插件调试步骤 AS分别打开插件的P项目和依赖插件的D项目 插件项目创建remote调试配置 打开D项目编辑依赖插件的gradle Task,填入上次记录的jvm配置，将suspend改为y(执行时task会等待调试项目Attach) 修改suspend 双击该任务执行Task，terminal会提示正在监听端口，任务被挂起。然后，返回P项目打上断点点击调试按钮，发现D项目Task继续执行了，这时表示调试就成功了。 其他方式通过命令行连接调试 修改gradle配置 1export GRADLE_OPTS&#x3D;&quot;-agentlib:jdwp&#x3D;transport&#x3D;dt_socket,server&#x3D;y,suspend&#x3D;y,address&#x3D;5008&quot; 命令行添加如下参数， 1.&#x2F;gradlew clean assembleDebug -Dorg.gradle.debug&#x3D;true --no-daemon 注 经过多次尝试都无法成功，D项目的任务会一直卡死在start daemon无法被调试唤醒。","tags":[{"name":"gradle","slug":"gradle","permalink":"https://mufans.github.io/tags/gradle/"}]}]